//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.11-2021/01/28-beta

`include "./includes/proj_verilog/sp_verilog.vh" //_\SV
`timescale 1ns / 1ps
   // Included URL: "https://raw.githubusercontent.com/mayank-kabra2001/WARPV-TSMC/main/warpv.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/1d1023ccf8e7b0a8cf8e8fc4f0a823ebb61008e3/risc-v_defs.tlv"
     

//_\SV
   module register_file(
        input  clk, 
        input  reset,
        input  is_reg_rs1,
        input  is_reg_rs2, 
        input  valid_decode, 
        input  dest_reg_valid, 
        input  [4:0] reg_rs1,
        input  [4:0] reg_rs2,
        input  [2:0] valid_dest_reg_valid_rd,
        input  [2:0] goodPathMask,
        input  [2:0] second_issue, 
        input  [2:0] dest_reg,
        input  dest_reg_now, 
        input  [2:0] rslt,
        input  [2:0] reg_wr_pending,
        output reg replay_int,
        output reg out_pending1,
        output reg out_pending2,
        output reg [31:0] reg_value1,
        output reg [31:0] reg_value2, 
        output reg dest_pending,
        input  valid_dest_reg_valid_wr,
        input  [4:0] dest_reg_wr,
        input  [31:0] rslt_wr,
        input  reg_wr_pending_wr
   );

`include "register_file_gen.v"
generate //_\TLV
   //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 4055   // Instantiated from register_file.tlv, 37 as: m4+register_file() 
      assign L0_is_reg_rs1_a0 = is_reg_rs1;
      assign L0_is_reg_rs2_a0 = is_reg_rs2;
      assign L0_reg_rs1_a0[4:0] = reg_rs1;
      assign L0_reg_rs2_a0[4:0] = reg_rs2;
      assign L0_valid_decode_a0 = valid_decode;
      assign L0_dest_reg_valid_a0 = dest_reg_valid; 
      assign L0_valid_dest_reg_valid_rd_a0[2:0] = valid_dest_reg_valid_rd;
      assign L0_goodPathMask_a0[2:0] = goodPathMask;
      assign L0_second_issue_a0[2:0] = second_issue; 
      assign L0_dest_reg_a0[2:0] = dest_reg;
      assign L0_dest_reg_now_a0 = dest_reg_now; 
      assign L0_rslt_a0[2:0] = rslt; 
      assign L0_reg_wr_pending_a0[2:0] = reg_wr_pending; 
            // WRITE SIGNALS //
            
      assign L0_valid_dest_reg_valid_wr_a0 = valid_dest_reg_valid_wr;
      assign L0_dest_reg_wr_a0[4:0] = dest_reg_wr;
      assign L0_rslt_wr_a0[31:0] = rslt_wr;
      assign L0_reg_wr_pending_wr_a0 = reg_wr_pending_wr; 
      
      //_/regs
         
      for (src = 1; src <= 2; src=src+1) begin : L1_Src //_/src

         // For $is_reg.
         wire L1_is_reg_a0;

         // For $is_reg_condition.
         wire L1_is_reg_condition_a0;

         // For $pending.
         wire L1_pending_a0;

         // For $reg.
         wire [4:0] L1_reg_a0;

         // For $reg_value.
         wire [31:0] L1_reg_value_a0;

         assign L1_is_reg_a0 = (src == 1) ? L0_is_reg_rs1_a0 : L0_is_reg_rs2_a0;
         assign L1_reg_a0[4:0] = (src == 1) ? L0_reg_rs1_a0 : L0_reg_rs2_a0;
         assign L1_is_reg_condition_a0 = L1_is_reg_a0 && L0_valid_decode_a0;  // Note: $is_reg can be set for RISC-V sr0.
         
         assign {L1_reg_value_a0[31:0], L1_pending_a0} = L1_is_reg_condition_a0 ? 
            (L1_reg_a0 == 5'b0) ? {32'b0, 1'b0} :  // Read r0 as 0 (not pending).
            // Bypass stages. Both register and pending are bypassed.
            // Bypassed registers must be from instructions that are good-path as of this instruction or are 2nd issuing.
            (L0_valid_dest_reg_valid_rd_a0[0] && (L0_goodPathMask_a0[0] || L0_second_issue_a0[0]) && (L0_dest_reg_a0[0] == L1_reg_a0)) ? {L0_rslt_a0[0], L0_reg_wr_pending_a0[0]} :
            (L0_valid_dest_reg_valid_rd_a0[1] && (L0_goodPathMask_a0[1] || L0_second_issue_a0[1]) && (L0_dest_reg_a0[1] == L1_reg_a0)) ? {L0_rslt_a0[1], L0_reg_wr_pending_a0[1]} :
            
            {Regs_value_a2[L1_reg_a0], Regs_pending_a2[L1_reg_a0]} : 0;
         // Replay if this source register is pending.
         assign Src_replay_a0[src] = L1_is_reg_condition_a0 && L1_pending_a0;
      end
        
         // Also replay for pending dest reg to keep writes in order. Bypass dest reg pending to support this.
      assign L0_is_dest_condition_a0 = L0_dest_reg_valid_a0 && L0_valid_decode_a0;  // Note, $dest_reg_valid is 0 for RISC-V sr0.
      assign L0_dest_pending_a0 = L0_is_dest_condition_a0 ? 
         (L0_dest_reg_now_a0 == 5'b0) ? 1'b0 :  // Read r0 as 0 (not pending). Not actually necessary, but it cuts off read of non-existent rs0, which might be an issue for formal verif tools.
         // Bypass stages. Both register and pending are bypassed.
         (L0_valid_dest_reg_valid_rd_a0[0] && (L0_goodPathMask_a0[0] || L0_second_issue_a0[0]) && (L0_dest_reg_a0[0] == L0_dest_reg_now_a0)) ? L0_reg_wr_pending_a0[0] :
         (L0_valid_dest_reg_valid_rd_a0[1] && (L0_goodPathMask_a0[1] || L0_second_issue_a0[1]) && (L0_dest_reg_a0[1] == L0_dest_reg_now_a0)) ? L0_reg_wr_pending_a0[1] :
         
         Regs_pending_a2[L0_dest_reg_a0] : 0;
         // Combine replay conditions for pending source or dest registers.
      assign L0_replay_int_a0 = | Src_replay_a0 || (L0_is_dest_condition_a0 && L0_dest_pending_a0);
      
      always@(L0_replay_int_a0) replay_int = L0_replay_int_a0;
      always@(L0_dest_pending_a0) dest_pending = L0_dest_pending_a0;
      always@(L1_Src[1].L1_reg_value_a0) reg_value1 = L1_Src[1].L1_reg_value_a0[31:0];
      always@(L1_Src[2].L1_reg_value_a0) reg_value2 = L1_Src[2].L1_reg_value_a0[31:0];
      always@(L1_Src[1].L1_pending_a0) out_pending1 = L1_Src[1].L1_pending_a0;
      always@(L1_Src[2].L1_pending_a0) out_pending2 = L1_Src[2].L1_pending_a0;
      
      assign L0_reg_write_a0 = reset ? 1'b0 : L0_valid_dest_reg_valid_wr_a0;
      
      /*\SV_plus
         if($reg_write)
            /regs[$dest_reg_wr]<<0$$^value[31:0] <= $rslt_wr;*/
      
      for (regs = 1; regs <= 31; regs=regs+1) begin : L1b_Regs //_/regs
         assign Regs_value_a0[regs][31:0] = ! reset && (((regs == L0_dest_reg_wr_a0) && L0_reg_write_a0) ? L0_rslt_wr_a0 : Regs_value_a1[regs][31:0]);
      end
         
      
      // Write $   \SV_pluspending along with $value, but coded differently because it must be reset.
      for (regs = 1; regs <= 31; regs=regs+1) begin : L1c_Regs //_/regs
         assign Regs_pending_n1[regs] = ! reset && (((regs == L0_dest_reg_wr_a0) && L0_valid_dest_reg_valid_wr_a0) ? L0_reg_wr_pending_wr_a0 : Regs_pending_a0[regs]);
         `BOGUS_USE(Regs_value_a0[regs])
      end
      
   //_\end_source 
endgenerate

//_\SV
   endmodule

