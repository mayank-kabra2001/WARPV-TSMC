//_\TLV_version 1d: tl-x.org, generated by SandPiper(TM) 1.11-2021/01/28-beta
`include "./includes/proj_verilog/sp_verilog.vh" //_\SV
   /*
   Copyright 2021 Redwood EDA
   
   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */


//_\source cpu.tlv 43
//_\SV
   // Included URL: "https://raw.githubusercontent.com/mayank-kabra2001/WARPV-TSMC/main/warpv.tlv"// Included URL: "https://raw.githubusercontent.com/stevehoover/warp-v_includes/1d1023ccf8e7b0a8cf8e8fc4f0a823ebb61008e3/risc-v_defs.tlv"

//_\SV
   // Include WARP-V.
   
   module cpu(input clk, input reset, output reg led);
   
      

                         
`include "cpu_gen.v"
generate //_\TLV
   // Generated logic
   // Instantiate the _gen macro for the right ISA. (This approach is required for an m4-defined name.)
   
   //_\source /raw.githubusercontent.com/stevehoover/warpvincludes/1d1023ccf8e7b0a8cf8e8fc4f0a823ebb61008e3/riscvdefs.tlv 223   // Instantiated from cpu.tlv, 59 as: m4+m4_gen()
   
      
      // v---------------------
      // Instruction characterization
   
      // M4 ugliness for instruction characterization.
      
      // For each opcode[6:2]
      // (User ISA Manual 2.2, Table 19.1)
      // Associate opcode[6:2] ([1:0] are 2'b11) with mnemonic and instruction type.
      // Instruction type is not in the table, but there seems to be a single instruction type for each of these,
      // so that is mapped here as well.
      // op5(bits, type, mnemonic)
      /*SV_plus*/
         
         
         
         
         
         
         
         
         
         
         
           // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
         
         
         
         
         
         
         
         
           // (R-type, but rs2 = const for some, based on funct7 which doesn't exist for I-type?? R-type w/ ignored R2?)
         
         
         
         
         
         
         
         
         
         
         
         
      /*SV_plus*/
         
         
      /*SV_plus*/
         // Instruction characterization.
         // (User ISA Manual 2.2, Table 19.2)
         // instr(type,  // (this is simply verified vs. op5)
         //       |  bit-width,
         //       |  |   extension, 
         //       |  |   |  opcode[6:2],  // (aka op5)
         //       |  |   |  |      func3,   // (if applicable)
         //       |  |   |  |      |    mnemonic)
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         //m4_instr(_, 32, I, 00011, 000, FENCE)
         //m4_instr(_, 32, I, 00011, 001, FENCE_I)
         //m4_instr(_, 32, I, 11100, 000, ECALL_EBREAK)  // Two instructions distinguished by an immediate bit, treated as a single instruction.
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         
         //m4_instr(R4, 32, B, 01100, 001, 11, CMIX)  // Currently we are excluing ternary BMI's for optimization, although its only a draft
         //m4_instr(R4, 32, B, 01100, 101, 11, CMOV)
         //m4_instr(R4, 32, B, 01100, 001, 10, FSL)
         //m4_instr(R4, 32, B, 01100, 101, 10, FSR)
         //m4_instr(R4, 32, B, 00100, 101, 10, FSRI)
          // single operand instruction are currently using R2-type rather than I-type encoding
         
         
         //m4_instr(R2, 64, B, 01100, 001, 0110000, 00011, BMATFLIP)
         
         
         
         
         
         //m4_instr(R2, 64, B, 01100, 001, 0110000, 10011, CRC32D)
         
         
         
         //m4_instr(R2, 64, B, 01100, 001, 0110000, 11011, CRC32CD)
         
         
         
         
         
         
         
         
         
         
         
         
         
         //m4_instr(R, 64, B, 01100, 011, 0000100, BMATOR)
         //m4_instr(R, 64, B, 01100, 011, 0100100, BMATXOR)
         
         
         
         
         //m4_instr(I, 64, B, 01100, 100, ADDIWU)
         //m4_instr(If, 64, B, 01100, 001, 000010, SLLIUW)
         //m4_instr(R, 64, B, 01110, 000, 0000101, ADDWU)
         //m4_instr(R, 64, B, 01110, 000, 0100101, SUBWU)
         //m4_instr(R, 64, B, 01110, 000, 0000100, ADDUW)
         //m4_instr(R, 64, B, 01110, 000, 0100100, SUBUW)
         //m4_instr(R, 64, B, 01110, 001, 0010000, SLOW)
         //m4_instr(R, 64, B, 01110, 101, 0010000, SROW)
         //m4_instr(R, 64, B, 01110, 001, 0110000, ROLW)
         //m4_instr(R, 64, B, 01110, 101, 0110000, RORW)
         //m4_instr(R, 64, B, 01110, 001, 0100100, SBCLRW)
         //m4_instr(R, 64, B, 01110, 001, 0010100, SBSETW)
         //m4_instr(R, 64, B, 01110, 001, 0110100, SBINVW)
         //m4_instr(R, 64, B, 01110, 101, 0100100, SBEXTW)
         //m4_instr(R, 64, B, 01110, 101, 0010100, GROCW)
         //m4_instr(R, 64, B, 01110, 101, 0110100, GREVW)
         //m4_instr(If, 64, B, 00110, 001, 001000, SLOIW)
         //m4_instr(If, 64, B, 00110, 101, 001000, SROIW)
         //m4_instr(If, 64, B, 00110, 101, 011000, RORIW)
         //m4_instr(If, 64, B, 00110, 001, 010010, SBCLRIW)
         //m4_instr(If, 64, B, 00110, 001, 001010, SBSETIW)
         //m4_instr(If, 64, B, 00110, 001, 011010, SBINVIW)
         //m4_instr(If, 64, B, 00110, 101, 001010, GORCIW)
         //m4_instr(If, 64, B, 00110, 101, 011010, GREVIW)
         //m4_instr(R4, 64, B, 01110, 001, 10, FSLW)
         //m4_instr(R4, 64, B, 01110, 101, 10, FSRW)
         //m4_instr(R4, 64, B, 00110, 101, 10, FSRIW) //rs2 is "imm"
         //m4_instr(R2, 64, B, 00110, 001, 0110000, 00000, CLZW)
         //m4_instr(R2, 64, B, 00110, 001, 0110000, 00001, CTZW)
         //m4_instr(R2, 64, B, 00110, 001, 0110000, 00010, PCNTW)
         //m4_instr(R, 64, B, 01110, 001, 0000101, CLMULW)
         //m4_instr(R, 64, B, 01110, 010, 0000101, CLMULRW)
         //m4_instr(R, 64, B, 01110, 011, 0000101, CLMULHW)
         //m4_instr(R, 64, B, 01110, 001, 0000100, SHFLW)
         //m4_instr(R, 64, B, 01110, 101, 0000100, UNSHFLW)
         //m4_instr(R, 64, B, 01110, 110, 0100100, BDEPW)
         //m4_instr(R, 64, B, 01110, 110, 0000100, BEXTW)
         //m4_instr(R, 64, B, 01110, 100, 0000100, PACKW)
         //m4_instr(R, 64, B, 01110, 100, 0100100, PACKUW)
         //m4_instr(R, 64, B, 01110, 111, 0100100, BFPW)
      // ^---------------------
   //_\end_source
   // Instruction memory and fetch of $raw.
   //m4+M4_IMEM_MACRO_NAME(M4_PROG_NAME)
   
   // /=========\
   // | instructions|
   // \=========/
   
   //_|fetch
      //_/instr
         //_@0
            //_?$fetch
               assign FETCH_Instr_addr_instr_sram_a0[11:0] = FETCH_Instr_Pc_a0[5 : 2] ;
               assign FETCH_Instr_raw_a0[31:0] = FETCH_Instr_dout_instr_a2;
               
   // /=========\
   // | The CPU |
   // \=========/
   
   //_|fetch
      //_/instr
         
         
         // Provide a longer reset to cover the pipeline depth.
         //_@-1
            always@(clk) led = 1; 
            assign FETCH_Instr_clk_n1 = clk; 
            assign FETCH_Instr_soft_reset_n1 = (1'b0) || reset;
            assign FETCH_Instr_Cnt_n2[7:0] = FETCH_Instr_soft_reset_n1   ? 8'b0 :       // reset
                         FETCH_Instr_Cnt_n1 == 8'hFF ? 8'hFF :      // max out to avoid wrapping
                                         FETCH_Instr_Cnt_n1 + 8'b1; // increment
            assign FETCH_Instr_reset_n1 = FETCH_Instr_soft_reset_n1 || FETCH_Instr_Cnt_n1 < 11;
         //_@0
            assign FETCH_Instr_fetch_a0 = ! FETCH_Instr_reset_a0 && ! FETCH_Instr_NoFetch_a0;
            // (M4_IMEM_MACRO_NAME instantiation produces ?$fetch$raw.)
         //_@0
            
            // ========
            // Overview
            // ========
            
            // Terminology:
            //
            // Instruction: An instruction, as viewed by the CPU pipeline (i.e. ld and returning_ld are separate instructions,
            //              and the returning_ld and the instruction it clobbers are one in the same).
            // ISA Instruction: An instruction, as defined by the ISA.
            // Good-Path (vs. Bad-Path): On the proper flow of execution of the program, excluding aborted instructions.
            // Path (of an instruction): The sequence of instructions that led to a particular instruction.
            // Current Path: The sequence of instructions fetched by next-PC logic that are not known to be bad-path.
            // Redirect: Adjust the PC from the predicted next-PC.
            // Redirect Shadow: Between the instruction causing the redirect and the redirect target instruction.
            // Bubbles: The cycles in the redirect shadow.
            // Commit: Results are made visible to subsequent instructions.
            // Abort: Do not commit. All aborts are also redirects and put the instruction on bad path. Non-aborting
            //        redirects do not mark the triggering instruction as bad-path. Aborts mask future redirects on the
            //        aborted instruction.
            // Retire: Commit results of an ISA instruction.
            
            // Control flow:
            //
            // Redirects include (earliest to latest):
            //   o Returning load: (aborting) A returning load clobbers an instruction and takes its slot, resulting in a
            //                     one-cycle redirect to repeat the clobbered instruction.
            //   o Predict-taken branch: A predicted-taken branch must determine the target before it can redirect the PC.
            //                           (This might be followed up by a mispredition.)
            //   o Replay: (aborting) Replay the same instruction (because a source register is pending (awaiting a long-latency/2nd issuing instruction))
            //   o Jump: A jump instruction.
            //   o Mispredicted branch: A branch condition was mispredicted.
            //   o Aborting traps: (aborting) illegal instructions, others?
            //   o Non-aborting traps: misaligned PC target
            
            // ==============
            // Redirect Logic
            // ==============
                            
            // PC logic will redirect the PC for conditions on current-path instructions. PC logic keeps track of which
            // instructions are on the current path with a $GoodPathMask. $GoodPathMask[n] of an instruction indicates
            // whether the instruction n instructions prior to this instruction is on its path.
            //
            //                 $GoodPathMask for Redir'edX => {o,X,o,y,y,y,o,o} == {1,1,1,1,0,0,1,1}
            // Waterfall View: |
            //                 V
            // 0)       oooooooo                  Good-path
            // 1) InstX  ooooooXo  (Non-aborting) Good-path
            // 2)         ooooooxx
            // 3) InstY    ooYyyxxx  (Aborting)
            // 4) InstZ     ooyyxZxx
            // 5) Redir'edY  oyyxxxxx
            // 6) TargetY     ooxxxxxx
            // 7) Redir'edX    oxxxxxxx
            // 8) TargetX       oooooooo          Good-path
            // 9) Not redir'edZ  oooooooo         Good-path
            //
            // Above depicts a waterfall diagram where three triggering redirection conditions X, Y, and Z are detected on three different
            // instructions. A trigger in the 1st depicted stage, M4_NEXT_PC_STAGE, results in a zero-bubble redirect so it would be
            // a condition that is factored directly into the next-PC logic of the triggering instruction, and it would have
            // no impact on the $GoodPathMask.
            //
            // Waveform View:
            //
            //   Inst 0123456789
            //        ---------- /
            // GPM[7]        ooxxxxxxoo
            // GPM[6]       oXxxxxxxoo
            // GPM[5]      oooxZxxxoo
            // GPM[4]     oooyxxxxoo
            // GPM[3]    oooyyxxxoo
            // GPM[2]   oooYyyxxoo
            // GPM[1]  oooooyoxoo
            // GPM[0] oooooooooo
            //          /
            //         Triggers for InstY
            //
            // In the waveform view, the mask shifts up each cycle, as instructions age, and trigger conditions mask instructions
            // in the shadow, down to the redirect target (GPM[0]).
            //
            // Terminology:
            //   Triggering instruction: The instruction on which the condition is detected.
            //   Redirected instruction: The instruction whose next PC is redirected.
            //   Redirection target instruction: The first new-path instruction resulting from the redirection.
            //
            // Above, Y redirects first, though it is for a later instruction than X. The redirections for X and Y are taken
            // because their instructions are on the path of the redirected instructions. Z is not on the path of its
            // potentially-redirected instruction, so no redirection happens.
            //
            // For simultaneous conditions on different instructions, the PC must redirect to the earlier instruction's
            // redirect target, so later-stage redirects take priority in the PC-mux.
            //
            // Aborting redirects result in the aborting instruction being marked as bad-path. Aborted instructions will
            // not commit. Subsequent redirect conditions on aborting instructions are ignored. (For conditions within the
            // same stage, this is accomplished by the PC-mux prioritization.)
            
            
            // Macros are defined elsewhere based on the ordered set of conditions that generate code here.
            
            // Redirect Shadow
            // A mask of stages ahead of this one (older) in which instructions are on the path of this instruction.
            // Index 1 is ahead by 1, etc.
            // In the example above, $GoodPathMask for Redir'edX == {0,0,0,0,1,1,0,0}
            //     (Looking up in the waterfall diagram from its first "o", in reverse order {o,X,o,o,y,y,o,o}.)
            // The LSB is fetch-valid. It only exists for m4_prev_instr_valid_through macro.
            assign FETCH_Instr_next_good_path_mask_a0[3+1:0] =
               // Shift up and mask w/ redirect conditions.
               {FETCH_Instr_GoodPathMask_a0[3:0]
                // & terms for each condition (order doesn't matter since masks are the same within a cycle)
                 & ((FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_pred_taken_branch_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{3{1'b1}}, {1{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_replay_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_indirect_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {{2{1'b1}}, {2{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_non_pipelined_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{0{1'b1}}, {4{1'b0}}} : {4{1'b1}}) & ((FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {{1{1'b1}}, {3{1'b0}}} : {4{1'b1}}),
                1'b1}; // Shift in 1'b1 (fetch-valid).
            
            assign FETCH_Instr_GoodPathMask_n1[3+1:0] =
               FETCH_Instr_reset_n1 ? 5'b0 :  // All bad-path (through self) on reset (next mask based on next reset).
               FETCH_Instr_next_good_path_mask_a0;
            
            
            
            
            
               
                
                
            
               
               
            
            
            
            // A returning load clobbers the instruction.
            // (Could do this with lower latency. Right now it goes through memory pipeline $ANY, and
            //  it is non-speculative. Both could easily be fixed.)
            assign FETCH_Instr_second_issue_ld_a0 = MEM_Data_valid_ld_a5 && 1'b1;
            assign FETCH_Instr_second_issue_a0 = FETCH_Instr_second_issue_ld_a0   ;
            // Recirculate returning load or the div_mul_result from /orig_inst scope
            
            //_?$second_issue_ld
               // This scope holds the original load for a returning load.
               //_/orig_load_inst
                  assign {FETCH_Instr_OrigLoadInst_addr_a0[1:0], FETCH_Instr_OrigLoadInst_dest_reg_a0[4:0], FETCH_Instr_OrigLoadInst_ld_st_half_a0, FETCH_Instr_OrigLoadInst_ld_st_word_a0, FETCH_Instr_OrigLoadInst_ld_value_a0[31:0], FETCH_Instr_OrigLoadInst_raw_funct3_a0[2], FETCH_Instr_OrigLoadInst_spec_ld_a0} = {MEM_Data_addr_a5, MEM_Data_dest_reg_a5, MEM_Data_ld_st_half_a5, MEM_Data_ld_st_word_a5, MEM_Data_ld_value_a5, MEM_Data_raw_funct3_a5, MEM_Data_spec_ld_a5};
                  for (src = 1; src <= 2; src=src+1) begin : L1_FETCH_Instr_OrigLoadInst_Src //_/src

                     // For $dummy.
                     wire L1_dummy_a0;

                     assign {L1_dummy_a0} = {L1_MEM_Data_Src[src].L1_dummy_a5};
                  end
            //_?$second_issue
               //_/orig_inst
                  // pull values from /orig_load_inst or /hold_inst depending on which second issue
                  assign {FETCH_Instr_OrigInst_dest_reg_a0[4:0]} = FETCH_Instr_second_issue_ld_a0 ? {FETCH_Instr_OrigLoadInst_dest_reg_a0} :    {FETCH_Instr_OrigLoadInst_dest_reg_a0};
                  for (src = 1; src <= 2; src=src+1) begin : L1_FETCH_Instr_OrigInst_Src //_/src

                     // For $dummy.
                     wire L1_dummy_a0;
                     reg  L1_dummy_a1,
                          L1_dummy_a2,
                          L1_dummy_a3,
                          L1_dummy_a4;

                     assign {L1_dummy_a0} = FETCH_Instr_second_issue_ld_a0 ? {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0} :    {L1_FETCH_Instr_OrigLoadInst_Src[src].L1_dummy_a0};
                  end
            
            // Next PC
            assign FETCH_Instr_pc_inc_a0[31:2] = FETCH_Instr_Pc_a0 + 30'b1;
            // Current parsing does not allow concatenated state on left-hand-side, so, first, a non-state expression.
            assign {FETCH_Instr_next_pc_a0[31:2], FETCH_Instr_next_no_fetch_a0} =
               FETCH_Instr_reset_a0 ? {30'b0, 1'b0} :
               // ? : terms for each condition (order does matter)
               (FETCH_Instr_non_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3 || FETCH_Instr_aborting_trap_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_trap_target_a3, 1'b0} : (FETCH_Instr_aborting_trap_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_trap_target_a3,1'b0} : (FETCH_Instr_non_pipelined_a3 && !(1'b0 || FETCH_Instr_second_issue_a3 || FETCH_Instr_NoFetch_a3 || FETCH_Instr_replay_a3) && FETCH_Instr_GoodPathMask_a0[3]) ? {FETCH_Instr_Pc_a3,1'b1} : (FETCH_Instr_indirect_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_indirect_jump_target_a2,1'b0} : (FETCH_Instr_mispred_branch_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_branch_redir_pc_a2,1'b0} : (FETCH_Instr_jump_a2 && !(1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2) && FETCH_Instr_GoodPathMask_a0[2]) ? {FETCH_Instr_jump_target_a2,1'b0} : (FETCH_Instr_replay_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {FETCH_Instr_Pc_a1,1'b0} : (FETCH_Instr_pred_taken_branch_a1 && !(1'b0 || FETCH_Instr_second_issue_a1 || FETCH_Instr_NoFetch_a1) && FETCH_Instr_GoodPathMask_a0[1]) ? {FETCH_Instr_branch_target_a1,1'b0} : (FETCH_Instr_NoFetch_a0 && !(1'b0 || FETCH_Instr_second_issue_a0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_Pc_a0,1'b1} : (FETCH_Instr_second_issue_a0 && !(1'b0) && FETCH_Instr_GoodPathMask_a0[0]) ? {FETCH_Instr_second_issue_ld_a0 ? FETCH_Instr_Pc_a0 : FETCH_Instr_pc_inc_a0,1'b0} :           
                          ({FETCH_Instr_pc_inc_a0, 1'b0});
            // Then as state.
            assign FETCH_Instr_Pc_n1[31:2] = FETCH_Instr_next_pc_a0;
            assign FETCH_Instr_NoFetch_n1 = FETCH_Instr_next_no_fetch_a0;
            
         //_@1
            
            // ======
            // DECODE
            // ======
            
            // Decode of the fetched instruction
            assign FETCH_Instr_valid_decode_a1 = FETCH_Instr_fetch_a1;  // Always decode if we fetch.
            assign FETCH_Instr_valid_decode_branch_a1 = FETCH_Instr_valid_decode_a1 && FETCH_Instr_branch_a1;
            // A load that will return later.
            //$split_ld = $spec_ld && 1'b['']M4_INJECT_RETURNING_LD;
            // Instantiate the program. (This approach is required for an m4-defined name.)
            
            //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1641   // Instantiated from cpu.tlv, 269 as: m4+m4_decode_macro_name()
               // TODO: ?$valid_<stage> conditioning should be replaced by use of m4_prev_instr_valid_through(..).
               //_?$valid_decode
                  // =================================
            
                  // Extract fields of $raw (instruction) into $raw_<field>[x:0].
                  assign {FETCH_Instr_raw_funct7_a1[6:0], FETCH_Instr_raw_rs2_a1[4:0], FETCH_Instr_raw_rs1_a1[4:0], FETCH_Instr_raw_funct3_a1[2:0], FETCH_Instr_raw_rd_a1[4:0], FETCH_Instr_raw_op5_a1[4:0], FETCH_Instr_raw_op2_a1[1:0]} = FETCH_Instr_raw_a1;
                  `BOGUS_USE(FETCH_Instr_raw_op2_a1)  // Delete once it's used.
                  // Extract immediate fields into type-specific signals.
                  // (User ISA Manual 2.2, Fig. 2.4)
                  assign FETCH_Instr_raw_i_imm_a1[31:0] = {{21{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[30:20]};
                  assign FETCH_Instr_raw_s_imm_a1[31:0] = {{21{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[30:25], FETCH_Instr_raw_a1[11:7]};
                  assign FETCH_Instr_raw_b_imm_a1[31:0] = {{20{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[7], FETCH_Instr_raw_a1[30:25], FETCH_Instr_raw_a1[11:8], 1'b0};
                  assign FETCH_Instr_raw_u_imm_a1[31:0] = {FETCH_Instr_raw_a1[31:12], {12{1'b0}}};
                  assign FETCH_Instr_raw_j_imm_a1[31:0] = {{12{FETCH_Instr_raw_a1[31]}}, FETCH_Instr_raw_a1[19:12], FETCH_Instr_raw_a1[20], FETCH_Instr_raw_a1[30:21], 1'b0};
                  // Extract other type/instruction-specific fields.
                  assign FETCH_Instr_raw_shamt_a1[6:0] = FETCH_Instr_raw_a1[26:20];
                  assign FETCH_Instr_raw_aq_a1 = FETCH_Instr_raw_a1[26];
                  assign FETCH_Instr_raw_rl_a1 = FETCH_Instr_raw_a1[25];
                  assign FETCH_Instr_raw_rs3_a1[4:0] = FETCH_Instr_raw_a1[31:27];
                  assign FETCH_Instr_raw_rm_a1[2:0] = FETCH_Instr_raw_funct3_a1;
                  `BOGUS_USE(FETCH_Instr_raw_shamt_a1 FETCH_Instr_raw_aq_a1 FETCH_Instr_raw_rl_a1 FETCH_Instr_raw_rs3_a1 FETCH_Instr_raw_rm_a1)  // Avoid "unused" messages. Remove these as they become used.
            
                  // Instruction type decode
                  /*SV_plus*/
                     assign FETCH_Instr_is_i_type_a1 = (((0 | (1 << 5'b00000) | (1 << 5'b00001) | (1 << 5'b00100) | (1 << 5'b00110) | (1 << 5'b11001) | (1 << 5'b11100)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_r_type_a1 = (((0 | (1 << 5'b01011) | (1 << 5'b01100) | (1 << 5'b01110) | (1 << 5'b10100)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_r2_type_a1 = (((0) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_r4_type_a1 = (((0 | (1 << 5'b10000) | (1 << 5'b10001) | (1 << 5'b10010) | (1 << 5'b10011)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_s_type_a1 = (((0 | (1 << 5'b01000) | (1 << 5'b01001)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_b_type_a1 = (((0 | (1 << 5'b11000)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_j_type_a1 = (((0 | (1 << 5'b11011)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is_u_type_a1 = (((0 | (1 << 5'b00101) | (1 << 5'b01101)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; assign FETCH_Instr_is___type_a1 = (((0 | (1 << 5'b00010) | (1 << 5'b00011) | (1 << 5'b00111) | (1 << 5'b01010) | (1 << 5'b01111) | (1 << 5'b10101) | (1 << 5'b10110) | (1 << 5'b10111) | (1 << 5'b11010) | (1 << 5'b11101) | (1 << 5'b11110) | (1 << 5'b11111)) >> FETCH_Instr_raw_op5_a1) & 32'b1) != 32'b0; 
            
                  // Instruction decode.
                  //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1618   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 1669 as: m4+riscv_decode_expr()
                     assign FETCH_Instr_is_lui_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01101;
                     assign FETCH_Instr_is_auipc_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00101;
                     assign FETCH_Instr_is_jal_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11011;
                     assign FETCH_Instr_is_jalr_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11001 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                     assign FETCH_Instr_is_beq_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                     assign FETCH_Instr_is_bne_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                     assign FETCH_Instr_is_blt_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                     assign FETCH_Instr_is_bge_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                     assign FETCH_Instr_is_bltu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                     assign FETCH_Instr_is_bgeu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11000 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                     assign FETCH_Instr_is_lb_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                     assign FETCH_Instr_is_lh_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                     assign FETCH_Instr_is_lw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                     assign FETCH_Instr_is_lbu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                     assign FETCH_Instr_is_lhu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00000 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                     assign FETCH_Instr_is_sb_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                     assign FETCH_Instr_is_sh_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                     assign FETCH_Instr_is_sw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01000 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                     assign FETCH_Instr_is_addi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b000;
                     assign FETCH_Instr_is_slti_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                     assign FETCH_Instr_is_sltiu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b011;
                     assign FETCH_Instr_is_xori_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b100;
                     assign FETCH_Instr_is_ori_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                     assign FETCH_Instr_is_andi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                     assign FETCH_Instr_is_slli_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b001 && FETCH_Instr_raw_funct7_a1[6:1] == 6'b000000;
                     assign FETCH_Instr_is_srli_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:1] == 6'b000000;
                     assign FETCH_Instr_is_srai_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b00100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:1] == 6'b010000;
                     assign FETCH_Instr_is_add_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b000 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_sub_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b000 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0100000;
                     assign FETCH_Instr_is_sll_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b001 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_slt_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b010 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_sltu_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b011 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_xor_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b100 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_srl_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_sra_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b101 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0100000;
                     assign FETCH_Instr_is_or_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b110 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_and_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b01100 && FETCH_Instr_raw_funct3_a1 == 3'b111 && FETCH_Instr_raw_funct7_a1[6:0] == 7'b0000000;
                     assign FETCH_Instr_is_csrrw_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b001;
                     assign FETCH_Instr_is_csrrs_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b010;
                     assign FETCH_Instr_is_csrrc_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b011;
                     assign FETCH_Instr_is_csrrwi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b101;
                     assign FETCH_Instr_is_csrrsi_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b110;
                     assign FETCH_Instr_is_csrrci_instr_a1 = FETCH_Instr_raw_op5_a1 == 5'b11100 && FETCH_Instr_raw_funct3_a1 == 3'b111;
                     
                  //_\end_source
                  
                  
                  
                  
                  
                  
                  
                  assign FETCH_Instr_div_mul_a1 = 1'b0;
                  assign FETCH_Instr_multype_instr_a1 = 1'b0;
                  `BOGUS_USE(FETCH_Instr_multype_instr_a1)
                  
            
                  
                  
                  
                  
                  
                  
                  
                  
                                        
                  
                                        
                  
                  
                  
                  
                  
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                                               
                  
                  
                                           
                                           
                                           
                                           
                  
                  
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                  
                  
                                             
                                             
                                             
                                             
                                             
                  
                  
                                            
                                            
                  
                  
                  
                  
                  
                  
                                      
                                      
                  
                                      
                                      
                                      
                                      
                                      
                  
                  
            
                  assign FETCH_Instr_is_srli_srai_instr_a1 = FETCH_Instr_is_srli_instr_a1 || FETCH_Instr_is_srai_instr_a1;
                  // Some I-type instructions have a funct7 field rather than immediate bits, so these must factor into the illegal instruction expression explicitly.
                  assign FETCH_Instr_illegal_itype_with_funct7_a1 = ( FETCH_Instr_is_srli_srai_instr_a1  ) && | {FETCH_Instr_raw_funct7_a1[6], FETCH_Instr_raw_funct7_a1[4:0]};
                  assign FETCH_Instr_illegal_a1 = (FETCH_Instr_illegal_itype_with_funct7_a1 && ! FETCH_Instr_is_lui_instr_a1 && ! FETCH_Instr_is_auipc_instr_a1 && ! FETCH_Instr_is_jal_instr_a1 && ! FETCH_Instr_is_jalr_instr_a1 && ! FETCH_Instr_is_beq_instr_a1 && ! FETCH_Instr_is_bne_instr_a1 && ! FETCH_Instr_is_blt_instr_a1 && ! FETCH_Instr_is_bge_instr_a1 && ! FETCH_Instr_is_bltu_instr_a1 && ! FETCH_Instr_is_bgeu_instr_a1 && ! FETCH_Instr_is_lb_instr_a1 && ! FETCH_Instr_is_lh_instr_a1 && ! FETCH_Instr_is_lw_instr_a1 && ! FETCH_Instr_is_lbu_instr_a1 && ! FETCH_Instr_is_lhu_instr_a1 && ! FETCH_Instr_is_sb_instr_a1 && ! FETCH_Instr_is_sh_instr_a1 && ! FETCH_Instr_is_sw_instr_a1 && ! FETCH_Instr_is_addi_instr_a1 && ! FETCH_Instr_is_slti_instr_a1 && ! FETCH_Instr_is_sltiu_instr_a1 && ! FETCH_Instr_is_xori_instr_a1 && ! FETCH_Instr_is_ori_instr_a1 && ! FETCH_Instr_is_andi_instr_a1 && ! FETCH_Instr_is_slli_instr_a1 && ! FETCH_Instr_is_srli_instr_a1 && ! FETCH_Instr_is_srai_instr_a1 && ! FETCH_Instr_is_add_instr_a1 && ! FETCH_Instr_is_sub_instr_a1 && ! FETCH_Instr_is_sll_instr_a1 && ! FETCH_Instr_is_slt_instr_a1 && ! FETCH_Instr_is_sltu_instr_a1 && ! FETCH_Instr_is_xor_instr_a1 && ! FETCH_Instr_is_srl_instr_a1 && ! FETCH_Instr_is_sra_instr_a1 && ! FETCH_Instr_is_or_instr_a1 && ! FETCH_Instr_is_and_instr_a1 && ! FETCH_Instr_is_csrrw_instr_a1 && ! FETCH_Instr_is_csrrs_instr_a1 && ! FETCH_Instr_is_csrrc_instr_a1 && ! FETCH_Instr_is_csrrwi_instr_a1 && ! FETCH_Instr_is_csrrsi_instr_a1 && ! FETCH_Instr_is_csrrci_instr_a1) ||
                             (FETCH_Instr_raw_a1[1:0] != 2'b11); // All legal instructions have opcode[1:0] == 2'b11. We ignore these bits in decode logic.
                  assign FETCH_Instr_conditional_branch_a1 = FETCH_Instr_is_b_type_a1;
               assign FETCH_Instr_jump_a1 = FETCH_Instr_is_jal_instr_a1;  // "Jump" in RISC-V means unconditional. (JALR is a separate redirect condition.)
               assign FETCH_Instr_branch_a1 = FETCH_Instr_is_b_type_a1;
               assign FETCH_Instr_indirect_jump_a1 = FETCH_Instr_is_jalr_instr_a1;
               //_?$valid_decode
                  assign FETCH_Instr_ld_a1 = FETCH_Instr_raw_a1[6:3] == 4'b0;
                  assign FETCH_Instr_st_a1 = FETCH_Instr_is_s_type_a1;
                  assign FETCH_Instr_ld_st_a1 = FETCH_Instr_ld_a1 || FETCH_Instr_st_a1;
                  assign FETCH_Instr_ld_st_word_a1 = FETCH_Instr_ld_st_a1 && (FETCH_Instr_raw_funct3_a1[1] == 1'b1);
                  assign FETCH_Instr_ld_st_half_a1 = FETCH_Instr_ld_st_a1 && (FETCH_Instr_raw_funct3_a1[1:0] == 2'b01);
                  //$ld_st_byte = $ld_st && ($raw_funct3[1:0] == 2'b00);
                  `BOGUS_USE(FETCH_Instr_is___type_a1 FETCH_Instr_is_u_type_a1)
            
                  // Output signals.
                  for (src = 1; src <= 2; src=src+1) begin : L1_FETCH_Instr_Src //_/src

                     // For $is_reg.
                     wire L1_is_reg_a1;

                     // For $reg.
                     wire [4:0] L1_reg_a1;

                     // Reg valid for this source, based on instruction type.
                     assign L1_is_reg_a1 =
                         
                         (FETCH_Instr_is_r_type_a1 || FETCH_Instr_is_r4_type_a1 || (FETCH_Instr_is_i_type_a1 && (src == 1)) || FETCH_Instr_is_r2_type_a1 || FETCH_Instr_is_s_type_a1 || FETCH_Instr_is_b_type_a1);
                     assign L1_reg_a1[4:0] = (src == 1) ? FETCH_Instr_raw_rs1_a1[4:0] : FETCH_Instr_raw_rs2_a1[4:0];
                  end
                     
                  // For debug.
                  assign FETCH_Instr_mnemonic_a1[10*8-1:0] = FETCH_Instr_is_lui_instr_a1 ? "LUI       " : FETCH_Instr_is_auipc_instr_a1 ? "AUIPC     " : FETCH_Instr_is_jal_instr_a1 ? "JAL       " : FETCH_Instr_is_jalr_instr_a1 ? "JALR      " : FETCH_Instr_is_beq_instr_a1 ? "BEQ       " : FETCH_Instr_is_bne_instr_a1 ? "BNE       " : FETCH_Instr_is_blt_instr_a1 ? "BLT       " : FETCH_Instr_is_bge_instr_a1 ? "BGE       " : FETCH_Instr_is_bltu_instr_a1 ? "BLTU      " : FETCH_Instr_is_bgeu_instr_a1 ? "BGEU      " : FETCH_Instr_is_lb_instr_a1 ? "LB        " : FETCH_Instr_is_lh_instr_a1 ? "LH        " : FETCH_Instr_is_lw_instr_a1 ? "LW        " : FETCH_Instr_is_lbu_instr_a1 ? "LBU       " : FETCH_Instr_is_lhu_instr_a1 ? "LHU       " : FETCH_Instr_is_sb_instr_a1 ? "SB        " : FETCH_Instr_is_sh_instr_a1 ? "SH        " : FETCH_Instr_is_sw_instr_a1 ? "SW        " : FETCH_Instr_is_addi_instr_a1 ? "ADDI      " : FETCH_Instr_is_slti_instr_a1 ? "SLTI      " : FETCH_Instr_is_sltiu_instr_a1 ? "SLTIU     " : FETCH_Instr_is_xori_instr_a1 ? "XORI      " : FETCH_Instr_is_ori_instr_a1 ? "ORI       " : FETCH_Instr_is_andi_instr_a1 ? "ANDI      " : FETCH_Instr_is_slli_instr_a1 ? "SLLI      " : FETCH_Instr_is_srli_instr_a1 ? "SRLI      " : FETCH_Instr_is_srai_instr_a1 ? "SRAI      " : FETCH_Instr_is_add_instr_a1 ? "ADD       " : FETCH_Instr_is_sub_instr_a1 ? "SUB       " : FETCH_Instr_is_sll_instr_a1 ? "SLL       " : FETCH_Instr_is_slt_instr_a1 ? "SLT       " : FETCH_Instr_is_sltu_instr_a1 ? "SLTU      " : FETCH_Instr_is_xor_instr_a1 ? "XOR       " : FETCH_Instr_is_srl_instr_a1 ? "SRL       " : FETCH_Instr_is_sra_instr_a1 ? "SRA       " : FETCH_Instr_is_or_instr_a1 ? "OR        " : FETCH_Instr_is_and_instr_a1 ? "AND       " : FETCH_Instr_is_csrrw_instr_a1 ? "CSRRW     " : FETCH_Instr_is_csrrs_instr_a1 ? "CSRRS     " : FETCH_Instr_is_csrrc_instr_a1 ? "CSRRC     " : FETCH_Instr_is_csrrwi_instr_a1 ? "CSRRWI    " : FETCH_Instr_is_csrrsi_instr_a1 ? "CSRRSI    " : FETCH_Instr_is_csrrci_instr_a1 ? "CSRRCI    " :  "ILLEGAL   ";
                  `BOGUS_USE(FETCH_Instr_mnemonic_a1)
               // Condition signals must not themselves be conditioned (currently).
               assign FETCH_Instr_dest_reg_a1[4:0] = 
                                                
                                                FETCH_Instr_second_issue_ld_a1 ? FETCH_Instr_OrigInst_dest_reg_a1 : FETCH_Instr_raw_rd_a1[4:0];
               assign FETCH_Instr_dest_reg_valid_a1 =  ((FETCH_Instr_valid_decode_a1 && ! FETCH_Instr_is_s_type_a1 && ! FETCH_Instr_is_b_type_a1) || FETCH_Instr_second_issue_a1) &&
                                 | FETCH_Instr_dest_reg_a1;   // r0 not valid.  TODO: Huh? What about FP? No formal failure?
               
               
               
               
                  
                  
                     
                     
                               
                                
                                
                                
                                
                               
                     
                     
               
                                                
               
               
               
               // Actually load.
               assign FETCH_Instr_spec_ld_a1 = FETCH_Instr_valid_decode_a1 && FETCH_Instr_ld_a1;
               
               // CSR decode.
               assign FETCH_Instr_is_csr_write_a1 = FETCH_Instr_is_csrrw_instr_a1 || FETCH_Instr_is_csrrwi_instr_a1;
               assign FETCH_Instr_is_csr_set_a1   = FETCH_Instr_is_csrrs_instr_a1 || FETCH_Instr_is_csrrsi_instr_a1;
               assign FETCH_Instr_is_csr_clear_a1 = FETCH_Instr_is_csrrc_instr_a1 || FETCH_Instr_is_csrrci_instr_a1;
               assign FETCH_Instr_is_csr_instr_a1 = FETCH_Instr_is_csr_write_a1 ||
                               FETCH_Instr_is_csr_set_a1   ||
                               FETCH_Instr_is_csr_clear_a1;
               assign FETCH_Instr_valid_csr_a1 = 1'b0 || FETCH_Instr_is_csr_cycle_a1 || FETCH_Instr_is_csr_cycleh_a1 || FETCH_Instr_is_csr_time_a1 || FETCH_Instr_is_csr_timeh_a1 || FETCH_Instr_is_csr_instret_a1 || FETCH_Instr_is_csr_instreth_a1;
               assign FETCH_Instr_csr_trap_a1 = FETCH_Instr_is_csr_instr_a1 && ! FETCH_Instr_valid_csr_a1;
            //_\end_source
         // Instantiate the program. (This approach is required for an m4-defined name.)
         
         //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 2897   // Instantiated from cpu.tlv, 272 as: m4+m4_branch_pred_macro_name()
            //_@1
               //_?$branch
                  assign FETCH_Instr_pred_taken_a1 = FETCH_Instr_BranchState_a3[1];
            //_@2
               assign FETCH_Instr_branch_or_reset_a2 = (FETCH_Instr_branch_a2 && FETCH_Instr_commit_a2) || FETCH_Instr_reset_a2;
               //_?$branch_or_reset
                  assign FETCH_Instr_BranchState_a1[1:0] =
                     FETCH_Instr_reset_a2 ? 2'b01 :
                     FETCH_Instr_taken_a2 ? (FETCH_Instr_BranchState_a2 == 2'b11 ? FETCH_Instr_BranchState_a2[1:0] : FETCH_Instr_BranchState_a2 + 2'b1) :
                              (FETCH_Instr_BranchState_a2 == 2'b00 ? FETCH_Instr_BranchState_a2[1:0] : FETCH_Instr_BranchState_a2 - 2'b1);
         //_\end_source
         
         //_@1
            // Pending value to write to dest reg. Loads (not replaced by returning ld) write pending.
            assign FETCH_Instr_reg_wr_pending_a1 = FETCH_Instr_ld_a1 && ! FETCH_Instr_second_issue_a1 && 1'b1;
            `BOGUS_USE(FETCH_Instr_reg_wr_pending_a1)  // Not used if no bypass and no pending.
            
            // ======
            // Reg Rd
            // ======
            
            // INPUT SIGNALS TO REGISTER FILE - READ//
            assign FETCH_Instr_is_reg1_rd_a1 = L1_FETCH_Instr_Src[1].L1_is_reg_a1;
            assign FETCH_Instr_is_reg2_rd_a1 = L1_FETCH_Instr_Src[2].L1_is_reg_a1;  
            assign FETCH_Instr_reg_rs1_rd_a1[4:0] = L1_FETCH_Instr_Src[1].L1_reg_a1;
            assign FETCH_Instr_reg_rs2_rd_a1[4:0] = L1_FETCH_Instr_Src[2].L1_reg_a1;  
            assign FETCH_Instr_valid_decode_rd_a1 = FETCH_Instr_valid_decode_a1;
            assign FETCH_Instr_valid_dest_reg_valid_rd_a1[2:0] = {FETCH_Instr_valid_dest_reg_valid_a4, FETCH_Instr_valid_dest_reg_valid_a3, FETCH_Instr_valid_dest_reg_valid_a2}; 
            assign FETCH_Instr_goodPathMask_rd_a1[2:0] = {FETCH_Instr_GoodPathMask_a1[3], FETCH_Instr_GoodPathMask_a1[2], FETCH_Instr_GoodPathMask_a1[1]};
            assign FETCH_Instr_second_issue_rd_a1[2:0] = {FETCH_Instr_second_issue_a4, FETCH_Instr_second_issue_a3, FETCH_Instr_second_issue_a2}; 
            assign FETCH_Instr_dest_reg_rd_a1[2:0] = {FETCH_Instr_dest_reg_a4, FETCH_Instr_dest_reg_a3, FETCH_Instr_dest_reg_a2};
            assign FETCH_Instr_rslt_rd_a1[2:0] = {FETCH_Instr_rslt_a4, FETCH_Instr_rslt_a3, FETCH_Instr_rslt_a2};
            assign FETCH_Instr_reg_wr_pending_rd_a1[2:0] = {FETCH_Instr_reg_wr_pending_a4, FETCH_Instr_reg_wr_pending_a3, FETCH_Instr_reg_wr_pending_a2}; 
            assign FETCH_Instr_dest_reg_valid_rd_a1 = FETCH_Instr_dest_reg_valid_a1;
            assign FETCH_Instr_dest_reg_now_rd_a1 = FETCH_Instr_dest_reg_a1; 
            
            // OUTPUT SIGNALS TO REGISTER FILE - READ// 
            for (src = 1; src <= 2; src=src+1) begin : L1b_FETCH_Instr_Src //_/src

               // For $dummy.
               wire L1_dummy_a1;
               reg  L1_dummy_a2,
                    L1_dummy_a3,
                    L1_dummy_a4;

               // For $pending.
               wire L1_pending_a1;

               // For $reg_value.
               wire [31:0] L1_reg_value_a1;
               reg  [31:0] L1_reg_value_a2;

               assign L1_reg_value_a1[31:0] = (src == 1) ? FETCH_Instr_out_reg_value1_rd_a1 : FETCH_Instr_out_reg_value2_rd_a1 ; 
               assign L1_pending_a1 = (src == 1) ? FETCH_Instr_out_pending1_rd_a1 : FETCH_Instr_out_pending2_rd_a1; 
               `BOGUS_USE(L1_pending_a1)
               assign L1_dummy_a1 = 0; 
               `BOGUS_USE(L1_dummy_a1)
            end
            
            assign FETCH_Instr_dest_pending_a1 = FETCH_Instr_out_dest_pending_rd_a1; 
            `BOGUS_USE(FETCH_Instr_dest_pending_a1)
            assign FETCH_Instr_replay_int_a1 = FETCH_Instr_replay_int_rd_a1; 
                        
            // Obtain source register values and pending bit for source registers. Bypass up to 3
            // stages.
            // It is not necessary to bypass pending, as we could delay the replay, but we implement
            // bypass for performance.
            // Pending has an additional read for the dest register as we need to replay for write-after-write
            // hazard as well as write-after-read. To replay for dest write with the same timing, we must also
            // bypass the dest reg's pending bit.
            
            /////////////////////////////////////////////////////////////////////////
            // NOW READING FROM THE REGISTER FILE INSIDE A MODULE IN INCLUDE FILE //
            ////////////////////////////////////////////////////////////////////////
            
            
            
            
            
            
            
            
            
            
               
               
                  
                     
                     
                     
                     
                     
                     
                     
               
               
               
            
            
            
               
                  
                  
                  
                  
                  
                  
            
            
            
            assign FETCH_Instr_replay_a1 = FETCH_Instr_replay_int_a1 ;
         
         // =======
         // Execute
         // =======
         
         // Instantiate the program. (This approach is required for an m4-defined name.)
         
         //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1822   // Instantiated from cpu.tlv, 365 as: m4+m4_exe_macro_name(@M4_EXECUTE_STAGE, @M4_RESULT_STAGE)
            // if M_EXT is enabled, this handles the stalling logic
            
            
            
         
            // if F_EXT is enabled, this handles the stalling logic
            
            
            
         
            // if B_EXT is enabled, this handles the stalling logic
            
            
            
            //_@1
               //_?$valid_decode_branch
                  assign FETCH_Instr_branch_target_a1[31:2] = FETCH_Instr_Pc_a1[31:2] + FETCH_Instr_raw_b_imm_a1[31:2];
                  assign FETCH_Instr_misaligned_pc_a1 = | FETCH_Instr_raw_b_imm_a1[1:0];
               //_?$jump  // (JAL, not JALR)
                  assign FETCH_Instr_jump_target_a1[31:2] = FETCH_Instr_Pc_a1[31:2] + FETCH_Instr_raw_j_imm_a1[31:2];
                  assign FETCH_Instr_misaligned_jump_target_a1 = FETCH_Instr_raw_j_imm_a1[1];
            //_@2
               // Execution.
               assign FETCH_Instr_valid_exe_a2 = FETCH_Instr_valid_decode_a2; // Execute if we decoded.
               
               
               
               
               
               
               
               
               
               
         
               
               
               
               
               
               
               
          
               
               
         
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
         
               
         
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
               
         
               
               
         
               // hold_inst scope is not needed when long latency instructions are disabled
               
               // Compute results for each instruction, independent of decode (power-hungry, but fast).
               //_?$valid_exe
                  assign FETCH_Instr_equal_a2 = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 == L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
               //_?$branch
                  assign FETCH_Instr_taken_a2 =
                     FETCH_Instr_is_j_type_a2 ||
                     (FETCH_Instr_is_beq_instr_a2 && FETCH_Instr_equal_a2) ||
                     (FETCH_Instr_is_bne_instr_a2 && ! FETCH_Instr_equal_a2) ||
                     ((FETCH_Instr_is_blt_instr_a2 || FETCH_Instr_is_bltu_instr_a2 || FETCH_Instr_is_bge_instr_a2 || FETCH_Instr_is_bgeu_instr_a2) &&
                      ((FETCH_Instr_is_bge_instr_a2 || FETCH_Instr_is_bgeu_instr_a2) ^
                       (({(FETCH_Instr_is_blt_instr_a2 ^ L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]), L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31-1:0]} <
                         {(FETCH_Instr_is_blt_instr_a2 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]), L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31-1:0]}
                        ) ^ ((L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] != L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]) & FETCH_Instr_is_bge_instr_a2)
                       )
                      )
                     );
               //_?$indirect_jump  // (JALR)
                  assign FETCH_Instr_indirect_jump_full_target_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + FETCH_Instr_raw_i_imm_a2;
                  assign FETCH_Instr_indirect_jump_target_a2[31:2] = FETCH_Instr_indirect_jump_full_target_a2[31:2];
                  assign FETCH_Instr_misaligned_indirect_jump_target_a2 = FETCH_Instr_indirect_jump_full_target_a2[1];
               //_?$valid_exe
                  // Compute each individual instruction result, combined per-instruction by a macro.
                  // TODO: Could provide some macro magic to specify combined instructions w/ a single result and mux select.
                  //       This would reduce code below and probably improve implementation.
                  
                  assign FETCH_Instr_lui_rslt_a2[31:0]   = {FETCH_Instr_raw_u_imm_a2[31:12], 12'b0};
                  assign FETCH_Instr_auipc_rslt_a2[31:0] = {FETCH_Instr_Pc_a2, 2'b0} + FETCH_Instr_raw_u_imm_a2;
                  assign FETCH_Instr_jal_rslt_a2[31:0]   = {FETCH_Instr_Pc_a2, 2'b0} + 4;
                  assign FETCH_Instr_jalr_rslt_a2[31:0]  = {FETCH_Instr_Pc_a2, 2'b0} + 4;
                  // Load instructions. If returning ld is enabled, load instructions write no meaningful result, so we use zeros.
                  
                  assign FETCH_Instr_lb_rslt_a2[31:0]    = 32'b0;
                  assign FETCH_Instr_lh_rslt_a2[31:0]    = 32'b0;
                  assign FETCH_Instr_lw_rslt_a2[31:0]    = 32'b0;
                  assign FETCH_Instr_lbu_rslt_a2[31:0]   = 32'b0;
                  assign FETCH_Instr_lhu_rslt_a2[31:0]   = 32'b0;
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  assign FETCH_Instr_xori_rslt_a2[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 ^ FETCH_Instr_raw_i_imm_a2;
                  assign FETCH_Instr_ori_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 | FETCH_Instr_raw_i_imm_a2;
                  assign FETCH_Instr_andi_rslt_a2[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 & FETCH_Instr_raw_i_imm_a2;
                  assign FETCH_Instr_slli_rslt_a2[31:0]  = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 << FETCH_Instr_raw_i_imm_a2[5:0];
                  assign FETCH_Instr_srli_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 >> FETCH_Instr_raw_i_imm_a2[5:0];
                  assign FETCH_Instr_srai_intermediate_rslt_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] ? FETCH_Instr_srli_intermediate_rslt_a2 | ((32'b0 - 1) << (32 - FETCH_Instr_raw_i_imm_a2[5:0]) ): FETCH_Instr_srli_intermediate_rslt_a2;
                  assign FETCH_Instr_srl_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 >> L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0];
                  assign FETCH_Instr_sra_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] ? FETCH_Instr_srl_rslt_a2 | ((32'b0 - 1) << (32 - L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0]) ): FETCH_Instr_srl_rslt_a2;
                  assign FETCH_Instr_slti_rslt_a2[31:0]  =  (L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] == FETCH_Instr_raw_i_imm_a2[31]) ? FETCH_Instr_sltiu_rslt_a2 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]};
                  assign FETCH_Instr_sltiu_rslt_a2[31:0] = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2 < FETCH_Instr_raw_i_imm_a2) ? 1 : 0;
                  assign FETCH_Instr_srai_rslt_a2[31:0]  = FETCH_Instr_srai_intermediate_rslt_a2;
                  assign FETCH_Instr_srli_rslt_a2[31:0]  = FETCH_Instr_srli_intermediate_rslt_a2;
                  assign FETCH_Instr_sll_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 << L1b_FETCH_Instr_Src[2].L1_reg_value_a2[4:0];
                  assign FETCH_Instr_slt_rslt_a2[31:0]   = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31] == L1b_FETCH_Instr_Src[2].L1_reg_value_a2[31]) ? FETCH_Instr_sltu_rslt_a2 : {31'b0,L1b_FETCH_Instr_Src[1].L1_reg_value_a2[31]};
                  assign FETCH_Instr_sltu_rslt_a2[31:0]  = (L1b_FETCH_Instr_Src[1].L1_reg_value_a2 < L1b_FETCH_Instr_Src[2].L1_reg_value_a2) ? 1 : 0;
                  assign FETCH_Instr_xor_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 ^ L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                  assign FETCH_Instr_or_rslt_a2[31:0]    = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 | L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                  assign FETCH_Instr_and_rslt_a2[31:0]   = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 & L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                  // CSR read instructions have the same result expression. Counting on synthesis to optimize result mux.
                  assign FETCH_Instr_csrrw_rslt_a2[31:0]  = FETCH_Instr_is_csr_instreth_a2 ? {{0{1'b0}},FETCH_Instr_csr_instreth_a2} : FETCH_Instr_is_csr_instret_a2 ? {{0{1'b0}},FETCH_Instr_csr_instret_a2} : FETCH_Instr_is_csr_timeh_a2 ? {{0{1'b0}},FETCH_Instr_csr_timeh_a2} : FETCH_Instr_is_csr_time_a2 ? {{0{1'b0}},FETCH_Instr_csr_time_a2} : FETCH_Instr_is_csr_cycleh_a2 ? {{0{1'b0}},FETCH_Instr_csr_cycleh_a2} : FETCH_Instr_is_csr_cycle_a2 ? {{0{1'b0}},FETCH_Instr_csr_cycle_a2} : 32'bx;
                  assign FETCH_Instr_csrrs_rslt_a2[31:0]  = FETCH_Instr_csrrw_rslt_a2;
                  assign FETCH_Instr_csrrc_rslt_a2[31:0]  = FETCH_Instr_csrrw_rslt_a2;
                  assign FETCH_Instr_csrrwi_rslt_a2[31:0] = FETCH_Instr_csrrw_rslt_a2;
                  assign FETCH_Instr_csrrsi_rslt_a2[31:0] = FETCH_Instr_csrrw_rslt_a2;
                  assign FETCH_Instr_csrrci_rslt_a2[31:0] = FETCH_Instr_csrrw_rslt_a2;
                  
                  // "M" Extension.
                  
                  
                  
                  
                  
         
                  
                  
                  
                  
                  
                  
                  
                  
                  
         
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
               
                  // "F" Extension.
                  
                  
                  
                  
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                  
                  
                  
         
                  
                  
                  
                  
                  
                  
                                        
                                        
                                        
                                        
                                        
                  
         
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                  
                  
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                                           
                  
                  
                  
                  
                  
                  
                  
                  
                  
         
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
         
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
         
            // CSR logic
            // ---------
            //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1533   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 2256 as: m4+riscv_csrs([''](m4_csrs)[''])
               
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1491   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 1535 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                  //--------------
                  // CSR CYCLE
                  //--------------
                  //_@1
                     assign FETCH_Instr_is_csr_cycle_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC00;
                  //_@2
                     // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                     // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                     
                     
                     
                     // hw_wr_mask conditioned by hw_wr.
                     assign FETCH_Instr_csr_cycle_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_cycle_hw_wr_a2}} & FETCH_Instr_csr_cycle_hw_wr_mask_a2;
                     // The CSR value, updated by side-effect writes.
                     assign FETCH_Instr_upd_csr_cycle_a2[31:0] =
                          (FETCH_Instr_csr_cycle_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycle_hw_wr_value_a2) | (~ FETCH_Instr_csr_cycle_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycle_a2);
                     
                     
                     
                     
                     
                     
                     
                     // Next value of the CSR.
                     assign FETCH_Instr_csr_cycle_masked_wr_value_a2[31:0] =
                          FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                     assign FETCH_Instr_csr_cycle_a1[31:0] =
                          FETCH_Instr_reset_a2 ? 32'b0 :
                          ! FETCH_Instr_commit_a2
                                 ? FETCH_Instr_upd_csr_cycle_a2 :
                          FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_cycle_a2
                                 ? FETCH_Instr_csr_cycle_masked_wr_value_a2 | (FETCH_Instr_upd_csr_cycle_a2 & ~ {32{1'b1}}) :
                          FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_cycle_a2
                                 ? FETCH_Instr_upd_csr_cycle_a2 |   FETCH_Instr_csr_cycle_masked_wr_value_a2 :
                          FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_cycle_a2
                                 ? FETCH_Instr_upd_csr_cycle_a2 & ~ FETCH_Instr_csr_cycle_masked_wr_value_a2 :
                          // No CSR instruction update, only h/w side-effects.
                                   FETCH_Instr_upd_csr_cycle_a2;
                     
               //_\end_source
               
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1491   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 1535 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                  //--------------
                  // CSR CYCLEH
                  //--------------
                  //_@1
                     assign FETCH_Instr_is_csr_cycleh_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC80;
                  //_@2
                     // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                     // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                     
                     
                     
                     // hw_wr_mask conditioned by hw_wr.
                     assign FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_cycleh_hw_wr_a2}} & FETCH_Instr_csr_cycleh_hw_wr_mask_a2;
                     // The CSR value, updated by side-effect writes.
                     assign FETCH_Instr_upd_csr_cycleh_a2[31:0] =
                          (FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycleh_hw_wr_value_a2) | (~ FETCH_Instr_csr_cycleh_hw_wr_en_mask_a2 & FETCH_Instr_csr_cycleh_a2);
                     
                     
                     
                     
                     
                     
                     
                     // Next value of the CSR.
                     assign FETCH_Instr_csr_cycleh_masked_wr_value_a2[31:0] =
                          FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                     assign FETCH_Instr_csr_cycleh_a1[31:0] =
                          FETCH_Instr_reset_a2 ? 32'b0 :
                          ! FETCH_Instr_commit_a2
                                 ? FETCH_Instr_upd_csr_cycleh_a2 :
                          FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_cycleh_a2
                                 ? FETCH_Instr_csr_cycleh_masked_wr_value_a2 | (FETCH_Instr_upd_csr_cycleh_a2 & ~ {32{1'b1}}) :
                          FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_cycleh_a2
                                 ? FETCH_Instr_upd_csr_cycleh_a2 |   FETCH_Instr_csr_cycleh_masked_wr_value_a2 :
                          FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_cycleh_a2
                                 ? FETCH_Instr_upd_csr_cycleh_a2 & ~ FETCH_Instr_csr_cycleh_masked_wr_value_a2 :
                          // No CSR instruction update, only h/w side-effects.
                                   FETCH_Instr_upd_csr_cycleh_a2;
                     
               //_\end_source
               
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1491   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 1535 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                  //--------------
                  // CSR TIME
                  //--------------
                  //_@1
                     assign FETCH_Instr_is_csr_time_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC01;
                  //_@2
                     // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                     // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                     
                     
                     
                     // hw_wr_mask conditioned by hw_wr.
                     assign FETCH_Instr_csr_time_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_time_hw_wr_a2}} & FETCH_Instr_csr_time_hw_wr_mask_a2;
                     // The CSR value, updated by side-effect writes.
                     assign FETCH_Instr_upd_csr_time_a2[31:0] =
                          (FETCH_Instr_csr_time_hw_wr_en_mask_a2 & FETCH_Instr_csr_time_hw_wr_value_a2) | (~ FETCH_Instr_csr_time_hw_wr_en_mask_a2 & FETCH_Instr_csr_time_a2);
                     
                     
                     
                     
                     
                     
                     
                     // Next value of the CSR.
                     assign FETCH_Instr_csr_time_masked_wr_value_a2[31:0] =
                          FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                     assign FETCH_Instr_csr_time_a1[31:0] =
                          FETCH_Instr_reset_a2 ? 32'b0 :
                          ! FETCH_Instr_commit_a2
                                 ? FETCH_Instr_upd_csr_time_a2 :
                          FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_time_a2
                                 ? FETCH_Instr_csr_time_masked_wr_value_a2 | (FETCH_Instr_upd_csr_time_a2 & ~ {32{1'b1}}) :
                          FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_time_a2
                                 ? FETCH_Instr_upd_csr_time_a2 |   FETCH_Instr_csr_time_masked_wr_value_a2 :
                          FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_time_a2
                                 ? FETCH_Instr_upd_csr_time_a2 & ~ FETCH_Instr_csr_time_masked_wr_value_a2 :
                          // No CSR instruction update, only h/w side-effects.
                                   FETCH_Instr_upd_csr_time_a2;
                     
               //_\end_source
               
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1491   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 1535 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                  //--------------
                  // CSR TIMEH
                  //--------------
                  //_@1
                     assign FETCH_Instr_is_csr_timeh_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC81;
                  //_@2
                     // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                     // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                     
                     
                     
                     // hw_wr_mask conditioned by hw_wr.
                     assign FETCH_Instr_csr_timeh_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_timeh_hw_wr_a2}} & FETCH_Instr_csr_timeh_hw_wr_mask_a2;
                     // The CSR value, updated by side-effect writes.
                     assign FETCH_Instr_upd_csr_timeh_a2[31:0] =
                          (FETCH_Instr_csr_timeh_hw_wr_en_mask_a2 & FETCH_Instr_csr_timeh_hw_wr_value_a2) | (~ FETCH_Instr_csr_timeh_hw_wr_en_mask_a2 & FETCH_Instr_csr_timeh_a2);
                     
                     
                     
                     
                     
                     
                     
                     // Next value of the CSR.
                     assign FETCH_Instr_csr_timeh_masked_wr_value_a2[31:0] =
                          FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                     assign FETCH_Instr_csr_timeh_a1[31:0] =
                          FETCH_Instr_reset_a2 ? 32'b0 :
                          ! FETCH_Instr_commit_a2
                                 ? FETCH_Instr_upd_csr_timeh_a2 :
                          FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_timeh_a2
                                 ? FETCH_Instr_csr_timeh_masked_wr_value_a2 | (FETCH_Instr_upd_csr_timeh_a2 & ~ {32{1'b1}}) :
                          FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_timeh_a2
                                 ? FETCH_Instr_upd_csr_timeh_a2 |   FETCH_Instr_csr_timeh_masked_wr_value_a2 :
                          FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_timeh_a2
                                 ? FETCH_Instr_upd_csr_timeh_a2 & ~ FETCH_Instr_csr_timeh_masked_wr_value_a2 :
                          // No CSR instruction update, only h/w side-effects.
                                   FETCH_Instr_upd_csr_timeh_a2;
                     
               //_\end_source
               
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1491   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 1535 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                  //--------------
                  // CSR INSTRET
                  //--------------
                  //_@1
                     assign FETCH_Instr_is_csr_instret_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC02;
                  //_@2
                     // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                     // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                     
                     
                     
                     // hw_wr_mask conditioned by hw_wr.
                     assign FETCH_Instr_csr_instret_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_instret_hw_wr_a2}} & FETCH_Instr_csr_instret_hw_wr_mask_a2;
                     // The CSR value, updated by side-effect writes.
                     assign FETCH_Instr_upd_csr_instret_a2[31:0] =
                          (FETCH_Instr_csr_instret_hw_wr_en_mask_a2 & FETCH_Instr_csr_instret_hw_wr_value_a2) | (~ FETCH_Instr_csr_instret_hw_wr_en_mask_a2 & FETCH_Instr_csr_instret_a2);
                     
                     
                     
                     
                     
                     
                     
                     // Next value of the CSR.
                     assign FETCH_Instr_csr_instret_masked_wr_value_a2[31:0] =
                          FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                     assign FETCH_Instr_csr_instret_a1[31:0] =
                          FETCH_Instr_reset_a2 ? 32'b0 :
                          ! FETCH_Instr_commit_a2
                                 ? FETCH_Instr_upd_csr_instret_a2 :
                          FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_instret_a2
                                 ? FETCH_Instr_csr_instret_masked_wr_value_a2 | (FETCH_Instr_upd_csr_instret_a2 & ~ {32{1'b1}}) :
                          FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_instret_a2
                                 ? FETCH_Instr_upd_csr_instret_a2 |   FETCH_Instr_csr_instret_masked_wr_value_a2 :
                          FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_instret_a2
                                 ? FETCH_Instr_upd_csr_instret_a2 & ~ FETCH_Instr_csr_instret_masked_wr_value_a2 :
                          // No CSR instruction update, only h/w side-effects.
                                   FETCH_Instr_upd_csr_instret_a2;
                     
               //_\end_source
               
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1491   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 1535 as: m4+riscv_csr(m4_echo(['m4_csr_']csr['_args']))
                  //--------------
                  // CSR INSTRETH
                  //--------------
                  //_@1
                     assign FETCH_Instr_is_csr_instreth_a1 = FETCH_Instr_raw_a1[31:20] == 12'hC82;
                  //_@2
                     // CSR update. Counting on synthesis to optimize each bit, based on {32{1'b1}}.
                     // Conditionally include code for h/w and s/w write based on side_effect param (0 - s/w, 1 - s/w + h/w, RO - neither).
                     
                     
                     
                     // hw_wr_mask conditioned by hw_wr.
                     assign FETCH_Instr_csr_instreth_hw_wr_en_mask_a2[31:0] = {32{FETCH_Instr_csr_instreth_hw_wr_a2}} & FETCH_Instr_csr_instreth_hw_wr_mask_a2;
                     // The CSR value, updated by side-effect writes.
                     assign FETCH_Instr_upd_csr_instreth_a2[31:0] =
                          (FETCH_Instr_csr_instreth_hw_wr_en_mask_a2 & FETCH_Instr_csr_instreth_hw_wr_value_a2) | (~ FETCH_Instr_csr_instreth_hw_wr_en_mask_a2 & FETCH_Instr_csr_instreth_a2);
                     
                     
                     
                     
                     
                     
                     
                     // Next value of the CSR.
                     assign FETCH_Instr_csr_instreth_masked_wr_value_a2[31:0] =
                          FETCH_Instr_csr_wr_value_a2[31:0] & {32{1'b1}};
                     assign FETCH_Instr_csr_instreth_a1[31:0] =
                          FETCH_Instr_reset_a2 ? 32'b0 :
                          ! FETCH_Instr_commit_a2
                                 ? FETCH_Instr_upd_csr_instreth_a2 :
                          FETCH_Instr_is_csr_write_a2 && FETCH_Instr_is_csr_instreth_a2
                                 ? FETCH_Instr_csr_instreth_masked_wr_value_a2 | (FETCH_Instr_upd_csr_instreth_a2 & ~ {32{1'b1}}) :
                          FETCH_Instr_is_csr_set_a2   && FETCH_Instr_is_csr_instreth_a2
                                 ? FETCH_Instr_upd_csr_instreth_a2 |   FETCH_Instr_csr_instreth_masked_wr_value_a2 :
                          FETCH_Instr_is_csr_clear_a2 && FETCH_Instr_is_csr_instreth_a2
                                 ? FETCH_Instr_upd_csr_instreth_a2 & ~ FETCH_Instr_csr_instreth_masked_wr_value_a2 :
                          // No CSR instruction update, only h/w side-effects.
                                   FETCH_Instr_upd_csr_instreth_a2;
                     
               //_\end_source
               
            //_\end_source
            //_@2
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1538   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 2258 as: m4+riscv_csr_logic()
                  
                  // CSR write value for CSR write instructions.
                  assign FETCH_Instr_csr_wr_value_a2[31:0] = FETCH_Instr_raw_funct3_a2[2] ? {27'b0, FETCH_Instr_raw_rs1_a2} : L1b_FETCH_Instr_Src[1].L1_reg_value_a2;
                  
               
                  // Counter CSR
                  //
                  
                  // Count within time unit. This is not reset on writes to time CSR, so time CSR is only accurate to time unit.
                  assign FETCH_Instr_RemainingCyclesWithinTimeUnit_a1[30-1:0] =
                       (FETCH_Instr_reset_a2 || FETCH_Instr_time_unit_expires_a2) ?
                              30'd999999999 :
                              FETCH_Instr_RemainingCyclesWithinTimeUnit_a2 - 30'b1;
                  assign FETCH_Instr_time_unit_expires_a2 = !( | FETCH_Instr_RemainingCyclesWithinTimeUnit_a2);  // reaches zero
                  
                  assign FETCH_Instr_full_csr_cycle_hw_wr_value_a2[63:0]   = {FETCH_Instr_csr_cycleh_a2,   FETCH_Instr_csr_cycle_a2  } + 64'b1;
                  assign FETCH_Instr_full_csr_time_hw_wr_value_a2[63:0]    = {FETCH_Instr_csr_timeh_a2,    FETCH_Instr_csr_time_a2   } + 64'b1;
                  assign FETCH_Instr_full_csr_instret_hw_wr_value_a2[63:0] = {FETCH_Instr_csr_instreth_a2, FETCH_Instr_csr_instret_a2} + 64'b1;
                  
                  
                  
                  
                  
                  
                  
                  
                  // CSR h/w side-effect write signals.
                  assign FETCH_Instr_csr_cycle_hw_wr_a2 = 1'b1;
                  assign FETCH_Instr_csr_cycle_hw_wr_mask_a2[31:0] = {32{1'b1}};
                  assign FETCH_Instr_csr_cycle_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a2[31:0];
                  assign FETCH_Instr_csr_cycleh_hw_wr_a2 = 1'b1;
                  assign FETCH_Instr_csr_cycleh_hw_wr_mask_a2[31:0] = {32{1'b1}};
                  assign FETCH_Instr_csr_cycleh_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_cycle_hw_wr_value_a2[63:32];
                  assign FETCH_Instr_csr_time_hw_wr_a2 = FETCH_Instr_time_unit_expires_a2;
                  assign FETCH_Instr_csr_time_hw_wr_mask_a2[31:0] = {32{1'b1}};
                  assign FETCH_Instr_csr_time_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a2[31:0];
                  assign FETCH_Instr_csr_timeh_hw_wr_a2 = FETCH_Instr_time_unit_expires_a2;
                  assign FETCH_Instr_csr_timeh_hw_wr_mask_a2[31:0] = {32{1'b1}};
                  assign FETCH_Instr_csr_timeh_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_time_hw_wr_value_a2[63:32];
                  assign FETCH_Instr_csr_instret_hw_wr_a2 = FETCH_Instr_commit_a2;
                  assign FETCH_Instr_csr_instret_hw_wr_mask_a2[31:0] = {32{1'b1}};
                  assign FETCH_Instr_csr_instret_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a2[31:0];
                  assign FETCH_Instr_csr_instreth_hw_wr_a2 = FETCH_Instr_commit_a2;
                  assign FETCH_Instr_csr_instreth_hw_wr_mask_a2[31:0] = {32{1'b1}};
                  assign FETCH_Instr_csr_instreth_hw_wr_value_a2[31:0] = FETCH_Instr_full_csr_instret_hw_wr_value_a2[63:32];
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  // For multicore CSRs:
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
               //_\end_source
               
               // Memory inputs.
               //_?$valid_exe
                  assign FETCH_Instr_unnatural_addr_trap_a2 = (FETCH_Instr_ld_st_word_a2 && (FETCH_Instr_addr_a2[1:0] != 2'b00)) || (FETCH_Instr_ld_st_half_a2 && FETCH_Instr_addr_a2[0]);
               assign FETCH_Instr_ld_st_cond_a2 = FETCH_Instr_ld_st_a2 && FETCH_Instr_valid_exe_a2;
               //_?$ld_st_cond
                  assign FETCH_Instr_addr_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2 + (FETCH_Instr_ld_a2 ? FETCH_Instr_raw_i_imm_a2 : FETCH_Instr_raw_s_imm_a2);
                  
                  // Hardware assumes natural alignment. Otherwise, trap, and handle in s/w (though no s/w provided).
               assign FETCH_Instr_st_cond_a2 = FETCH_Instr_st_a2 && FETCH_Instr_valid_exe_a2;
               //_?$st_cond
                  // Provide a value to store, naturally-aligned to memory, that will work regardless of the lower $addr bits.
                  assign FETCH_Instr_st_reg_value_a2[31:0] = 
                                                                 L1b_FETCH_Instr_Src[2].L1_reg_value_a2;
                  assign FETCH_Instr_st_value_a2[31:0] =
                       FETCH_Instr_ld_st_word_a2 ? FETCH_Instr_st_reg_value_a2 :            // word
                       FETCH_Instr_ld_st_half_a2 ? {2{FETCH_Instr_st_reg_value_a2[15:0]}} : // half
                                     {4{FETCH_Instr_st_reg_value_a2[7:0]}};   // byte
                  assign FETCH_Instr_st_mask_a2[3:0] =
                       FETCH_Instr_ld_st_word_a2 ? 4'hf :                     // word
                       FETCH_Instr_ld_st_half_a2 ? (FETCH_Instr_addr_a2[1] ? 4'hc : 4'h3) : // half
                                     (4'h1 << FETCH_Instr_addr_a2[1:0]);      // byte
         
               // Swizzle bytes for load result (assuming natural alignment) and pass to /orig_load_inst scope
               //_?$second_issue_ld
                  //_/orig_load_inst
                     assign FETCH_Instr_OrigLoadInst_spec_ld_cond_a2 = FETCH_Instr_OrigLoadInst_spec_ld_a2;
                     //_?$spec_ld_cond
                        // (Verilator didn't like indexing $ld_value by signal math, so we do these the long way.)
                        assign FETCH_Instr_OrigLoadInst_sign_bit_a2 =
                           ! FETCH_Instr_OrigLoadInst_raw_funct3_a2[2] && (  // Signed && ...
                              FETCH_Instr_OrigLoadInst_ld_st_word_a2 ? FETCH_Instr_OrigLoadInst_ld_value_a2[31] :
                              FETCH_Instr_OrigLoadInst_ld_st_half_a2 ? (FETCH_Instr_OrigLoadInst_addr_a2[1] ? FETCH_Instr_OrigLoadInst_ld_value_a2[31] : FETCH_Instr_OrigLoadInst_ld_value_a2[15]) :
                                            ((FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b00) ? FETCH_Instr_OrigLoadInst_ld_value_a2[7] :
                                             (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b01) ? FETCH_Instr_OrigLoadInst_ld_value_a2[15] :
                                             (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b10) ? FETCH_Instr_OrigLoadInst_ld_value_a2[23] :
                                                                     FETCH_Instr_OrigLoadInst_ld_value_a2[31]
                                            )
                           );
                        assign {FETCH_Instr_OrigLoadInst_ld_rslt_a2[31:0], FETCH_Instr_OrigLoadInst_ld_mask_a2[3:0]} =
                             FETCH_Instr_OrigLoadInst_ld_st_word_a2 ? {FETCH_Instr_OrigLoadInst_ld_value_a2, 4'b1111} :
                             FETCH_Instr_OrigLoadInst_ld_st_half_a2 ? {{16{FETCH_Instr_OrigLoadInst_sign_bit_a2}}, FETCH_Instr_OrigLoadInst_addr_a2[1] ? {FETCH_Instr_OrigLoadInst_ld_value_a2[31:16], 4'b1100} :
                                                                        {FETCH_Instr_OrigLoadInst_ld_value_a2[15:0] , 4'b0011}} :
                                           {{24{FETCH_Instr_OrigLoadInst_sign_bit_a2}}, (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b00) ? {FETCH_Instr_OrigLoadInst_ld_value_a2[7:0]  , 4'b0001} :
                                                             (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b01) ? {FETCH_Instr_OrigLoadInst_ld_value_a2[15:8] , 4'b0010} :
                                                             (FETCH_Instr_OrigLoadInst_addr_a2[1:0] == 2'b10) ? {FETCH_Instr_OrigLoadInst_ld_value_a2[23:16], 4'b0100} :
                                                                                     {FETCH_Instr_OrigLoadInst_ld_value_a2[31:24], 4'b1000}};
                        `BOGUS_USE(FETCH_Instr_OrigLoadInst_ld_mask_a2) // It's only for formal verification.
               // ISA-specific trap conditions:
               // I can't see in the spec which of these is to commit results. I've made choices that make riscv-formal happy.
               assign FETCH_Instr_non_aborting_isa_trap_a2 = (FETCH_Instr_branch_a2 && FETCH_Instr_taken_a2 && FETCH_Instr_misaligned_pc_a2) ||
                                        (FETCH_Instr_jump_a2 && FETCH_Instr_misaligned_jump_target_a2) ||
                                        (FETCH_Instr_indirect_jump_a2 && FETCH_Instr_misaligned_indirect_jump_target_a2);
               assign FETCH_Instr_aborting_isa_trap_a2 =     (FETCH_Instr_ld_st_a2 && FETCH_Instr_unnatural_addr_trap_a2) ||
                                        FETCH_Instr_csr_trap_a2;
               
            //_@2
               // Mux the correct result.
               //_\source /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv 1621   // Instantiated from /raw.githubusercontent.com/mayankkabra2001/WARPVTSMC/main/warpv.tlv, 2317 as: m4+riscv_rslt_mux_expr()
                  // in case of second issue, the results are pulled out of the /orig_inst or /load_inst scope. 
                  // no alignment is needed as the rslt mux and the long latency results both appear in the same pipestage.
               
                  // in the case of second isssue for multiplication with ALTOPS enabled (or running formal checks for M extension), 
                  // the module gives out the result in two cycles but we explicitly flop the $mul_rslt 
                  // (by alignment with 3+NON_PIPELINED_BUBBLES to augment the 5 cycle behavior of the mul operation
               
                  assign FETCH_Instr_rslt_a2[31:0] =
                        FETCH_Instr_second_issue_ld_a2 ? FETCH_Instr_OrigLoadInst_ld_rslt_a2 : 
                        
                        
                         
                        
                         
                        
                        
                        
                        32'b0 |
                      ({32{FETCH_Instr_is_lui_instr_a2}} & FETCH_Instr_lui_rslt_a2) |
                      ({32{FETCH_Instr_is_auipc_instr_a2}} & FETCH_Instr_auipc_rslt_a2) |
                      ({32{FETCH_Instr_is_jal_instr_a2}} & FETCH_Instr_jal_rslt_a2) |
                      ({32{FETCH_Instr_is_jalr_instr_a2}} & FETCH_Instr_jalr_rslt_a2) |
                      ({32{FETCH_Instr_is_lb_instr_a2}} & FETCH_Instr_lb_rslt_a2) |
                      ({32{FETCH_Instr_is_lh_instr_a2}} & FETCH_Instr_lh_rslt_a2) |
                      ({32{FETCH_Instr_is_lw_instr_a2}} & FETCH_Instr_lw_rslt_a2) |
                      ({32{FETCH_Instr_is_lbu_instr_a2}} & FETCH_Instr_lbu_rslt_a2) |
                      ({32{FETCH_Instr_is_lhu_instr_a2}} & FETCH_Instr_lhu_rslt_a2) |
                      ({32{FETCH_Instr_is_addi_instr_a2}} & FETCH_Instr_addi_rslt_a2) |
                      ({32{FETCH_Instr_is_slti_instr_a2}} & FETCH_Instr_slti_rslt_a2) |
                      ({32{FETCH_Instr_is_sltiu_instr_a2}} & FETCH_Instr_sltiu_rslt_a2) |
                      ({32{FETCH_Instr_is_xori_instr_a2}} & FETCH_Instr_xori_rslt_a2) |
                      ({32{FETCH_Instr_is_ori_instr_a2}} & FETCH_Instr_ori_rslt_a2) |
                      ({32{FETCH_Instr_is_andi_instr_a2}} & FETCH_Instr_andi_rslt_a2) |
                      ({32{FETCH_Instr_is_slli_instr_a2}} & FETCH_Instr_slli_rslt_a2) |
                      ({32{FETCH_Instr_is_srli_instr_a2}} & FETCH_Instr_srli_rslt_a2) |
                      ({32{FETCH_Instr_is_srai_instr_a2}} & FETCH_Instr_srai_rslt_a2) |
                      ({32{FETCH_Instr_is_add_instr_a2}} & FETCH_Instr_add_rslt_a2) |
                      ({32{FETCH_Instr_is_sub_instr_a2}} & FETCH_Instr_sub_rslt_a2) |
                      ({32{FETCH_Instr_is_sll_instr_a2}} & FETCH_Instr_sll_rslt_a2) |
                      ({32{FETCH_Instr_is_slt_instr_a2}} & FETCH_Instr_slt_rslt_a2) |
                      ({32{FETCH_Instr_is_sltu_instr_a2}} & FETCH_Instr_sltu_rslt_a2) |
                      ({32{FETCH_Instr_is_xor_instr_a2}} & FETCH_Instr_xor_rslt_a2) |
                      ({32{FETCH_Instr_is_srl_instr_a2}} & FETCH_Instr_srl_rslt_a2) |
                      ({32{FETCH_Instr_is_sra_instr_a2}} & FETCH_Instr_sra_rslt_a2) |
                      ({32{FETCH_Instr_is_or_instr_a2}} & FETCH_Instr_or_rslt_a2) |
                      ({32{FETCH_Instr_is_and_instr_a2}} & FETCH_Instr_and_rslt_a2) |
                      ({32{FETCH_Instr_is_csrrw_instr_a2}} & FETCH_Instr_csrrw_rslt_a2) |
                      ({32{FETCH_Instr_is_csrrs_instr_a2}} & FETCH_Instr_csrrs_rslt_a2) |
                      ({32{FETCH_Instr_is_csrrc_instr_a2}} & FETCH_Instr_csrrc_rslt_a2) |
                      ({32{FETCH_Instr_is_csrrwi_instr_a2}} & FETCH_Instr_csrrwi_rslt_a2) |
                      ({32{FETCH_Instr_is_csrrsi_instr_a2}} & FETCH_Instr_csrrsi_rslt_a2) |
                      ({32{FETCH_Instr_is_csrrci_instr_a2}} & FETCH_Instr_csrrci_rslt_a2);
                  
               //_\end_source
         //_\end_source
         
         //_@2
            //_?$valid_exe
               // INPUT SIGNALS TO ALU - ADDER//
               assign FETCH_Instr_reg_value1_alu_a2[31:0] = L1b_FETCH_Instr_Src[1].L1_reg_value_a2; 
               assign FETCH_Instr_reg_value2_alu_a2[31:0] = L1b_FETCH_Instr_Src[2].L1_reg_value_a2; 
               assign FETCH_Instr_raw_i_imm_alu_a2[31:0] = FETCH_Instr_raw_i_imm_a2; 
               assign FETCH_Instr_raw_funct7_5_alu_a2 = FETCH_Instr_raw_funct7_a2[5];
               assign FETCH_Instr_valid_exe_alu_a2 = FETCH_Instr_valid_exe_a2; 
               
               // OUTPUT SIGNALS TO ALU - ADDER//
               assign FETCH_Instr_addi_rslt_a2[31:0] = FETCH_Instr_addi_rslt_out_a2; 
               assign FETCH_Instr_add_rslt_a2[31:0] = FETCH_Instr_add_rslt_out_a2; 
               assign FETCH_Instr_sub_rslt_a2[31:0] = FETCH_Instr_sub_rslt_out_a2; 
            
            
         //_@1
            assign FETCH_Instr_pred_taken_branch_a1 = FETCH_Instr_pred_taken_a1 && FETCH_Instr_branch_a1;
         //_@2
            
            // =======
            // Control
            // =======
            
            // A version of PC we can pull through $ANYs.
            assign FETCH_Instr_pc_a2[31:2] = FETCH_Instr_Pc_a2[31:2];
            `BOGUS_USE(FETCH_Instr_pc_a2)
            
            
            // Execute stage redirect conditions.
            assign FETCH_Instr_non_pipelined_a2 = FETCH_Instr_div_mul_a2  ;
            assign FETCH_Instr_replay_trap_a2 = 1'b0;
            assign FETCH_Instr_aborting_trap_a2 = FETCH_Instr_replay_trap_a2 || (FETCH_Instr_valid_decode_a2 && FETCH_Instr_illegal_a2) || FETCH_Instr_aborting_isa_trap_a2;
            assign FETCH_Instr_non_aborting_trap_a2 = FETCH_Instr_non_aborting_isa_trap_a2;
            assign FETCH_Instr_mispred_branch_a2 = FETCH_Instr_branch_a2 && ! (FETCH_Instr_conditional_branch_a2 && (FETCH_Instr_taken_a2 == FETCH_Instr_pred_taken_a2));
            //_?$valid_decode_branch
               assign FETCH_Instr_branch_redir_pc_a2[31:2] =
                  // If fallthrough predictor, branch mispred always redirects taken, otherwise PC+1 for not-taken.
                  (! FETCH_Instr_taken_a2) ? FETCH_Instr_Pc_a2 + 30'b1 :
                  FETCH_Instr_branch_target_a2;
                  
            assign FETCH_Instr_trap_target_a2[31:2] = FETCH_Instr_replay_trap_a2 ? FETCH_Instr_Pc_a2 : {30{1'b1}};  // TODO: What should this be? Using ones to terminate test for now.
            
            // Determine whether the instruction should commit it's result.
            //
            // Abort: Instruction triggers a condition causing a no-commit.
            // Commit: Ultimate decision to commit results of this instruction, considering aborts and
            //         prior-instruction redirects (good-path)
            //
            // Treatment of loads:
            //    Loads will commit. They write a garbage value and "pending" to the register file.
            //    Returning loads clobber an instruction. This instruction is $abort'ed (as is the
            //    returning load, since they are one in the same). Returning load must explicitly
            //    write results.
            //
            
            assign FETCH_Instr_abort_a2 = 1'b0 || FETCH_Instr_second_issue_a2 || FETCH_Instr_NoFetch_a2 || FETCH_Instr_replay_a2 || FETCH_Instr_aborting_trap_a2;  // Note that register bypass logic requires that abort conditions also redirect.
            // $commit = m4_prev_instr_valid_through(M4_MAX_REDIRECT_BUBBLES + 1), where +1 accounts for this
            // instruction's redirects. However, to meet timing, we consider this instruction separately, so,
            // commit if valid as of the latest redirect from prior instructions and not abort of this instruction.
            
            // Normal case:
            assign FETCH_Instr_good_path_a2 = (! FETCH_Instr_reset_a2 && FETCH_Instr_next_good_path_mask_a0[3]);
            assign FETCH_Instr_commit_a2 = FETCH_Instr_good_path_a2 && ! FETCH_Instr_abort_a2;
            
            
            
            
            
            
            // Conditions that commit results.
            assign FETCH_Instr_valid_dest_reg_valid_a2 = (FETCH_Instr_dest_reg_valid_a2 && FETCH_Instr_commit_a2) || (FETCH_Instr_second_issue_a2  );
            
            
            
            
            assign FETCH_Instr_valid_ld_a2 = FETCH_Instr_ld_a2 && FETCH_Instr_commit_a2;
            assign FETCH_Instr_valid_st_a2 = FETCH_Instr_st_a2 && FETCH_Instr_commit_a2;
            
   //_|fetch
      //_/instr
         //_@4
            // =========
            // Reg Write
            // =========
            
            // INPUT SIGNALS TO REGISTER FILE - WRITE//
            assign FETCH_Instr_valid_dest_reg_valid_wr_a4 = FETCH_Instr_valid_dest_reg_valid_a4;
            assign FETCH_Instr_dest_reg_wr_a4[4:0] = FETCH_Instr_dest_reg_a4;
            assign FETCH_Instr_rslt_wr_a4[31:0] = FETCH_Instr_rslt_a4;
            assign FETCH_Instr_reg_wr_pending_wr_a4 = FETCH_Instr_reg_wr_pending_a4;             
            
            /////////////////////////////////////////////////////////////////////////
            // NOW WRITING IN THE REGISTER FILE INSIDE A MODULE IN INCLUDE FILE //
            ////////////////////////////////////////////////////////////////////////
            
            
            
            
            
            
            
               
                  
                     
               
            
            
            
               
              
            
            
         //_@4
            `BOGUS_USE(L1_FETCH_Instr_OrigInst_Src[2].L1_dummy_a4) // To pull $dummy through $ANY expressions, avoiding empty expressions.
         
         // ====
         // Load
         // ====
         
         //_@4
            //_?$spec_ld
               assign FETCH_Instr_addr_data_load_sram_a4[11:0] = FETCH_Instr_addr_a4[4 + 2 : 2]; 
               assign FETCH_Instr_ld_value_a4[(32 / 4) - 1 : 0] = FETCH_Instr_dout_data_a4;           
         // =====
         // Store
         // =====
      for (byte_en = 0; byte_en <= 3; byte_en=byte_en+1) begin : L1_FETCH_ByteEn //_/byte_en

         // For $write_enable_byte.
         wire L1_write_enable_byte_a4;

         //_@4
            assign L1_write_enable_byte_a4 = (FETCH_Instr_valid_st_a4 && FETCH_Instr_st_mask_a4[byte_en]) ? 1 : 0;
      end
            
      //_/instr
         //_@4
            assign FETCH_Instr_web_a4 = {L1_FETCH_ByteEn[3].L1_write_enable_byte_a4,L1_FETCH_ByteEn[2].L1_write_enable_byte_a4,L1_FETCH_ByteEn[1].L1_write_enable_byte_a4,L1_FETCH_ByteEn[0].L1_write_enable_byte_a4};
            assign FETCH_Instr_check_en_valid_a4 = (FETCH_Instr_web_a4 == 0) ? 0 : 1 ; 
            //_?$check_en_valid
               assign FETCH_Instr_addr_data_store_sram_a4[11:0] = FETCH_Instr_addr_a4[4 + 2 : 2]; 
               assign FETCH_Instr_din_data_a4[31:0] = FETCH_Instr_st_value_a4;
            assign FETCH_Instr_addr_data_sram_a4[11:0] = (FETCH_Instr_spec_ld_a4 == 1) ? FETCH_Instr_addr_data_load_sram_a4 : (FETCH_Instr_check_en_valid_a4 == 1) ? FETCH_Instr_addr_data_store_sram_a4 : 0; 
            `BOGUS_USE(FETCH_Instr_ld_value_a4)
            `BOGUS_USE(FETCH_Instr_valid_ld_a4)
   //_|mem
      //_/data
         //_@4
            assign {MEM_Data_addr_a4[1:0], MEM_Data_dest_reg_a4[4:0], MEM_Data_ld_st_half_a4, MEM_Data_ld_st_word_a4, MEM_Data_ld_value_a4[31:0], MEM_Data_raw_funct3_a4[2], MEM_Data_spec_ld_a4, MEM_Data_valid_ld_a4} = {FETCH_Instr_addr_a4[1:0], FETCH_Instr_dest_reg_a4, FETCH_Instr_ld_st_half_a4, FETCH_Instr_ld_st_word_a4, FETCH_Instr_ld_value_a4[31:0], FETCH_Instr_raw_funct3_a4[2], FETCH_Instr_spec_ld_a4, FETCH_Instr_valid_ld_a4};
            for (src = 1; src <= 2; src=src+1) begin : L1_MEM_Data_Src //_/src

               // For $dummy.
               wire L1_dummy_a4;
               reg  L1_dummy_a5;

               assign {L1_dummy_a4} = {L1b_FETCH_Instr_Src[src].L1_dummy_a4};
            end
               
            
   //_|fetch 
      //_/instr 
         //_@1
            /*SV_plus*/
               register_file reg_file(
                          .clk(clk), 
                          .reset(FETCH_Instr_reset_a1),
                          .is_reg_rs1(FETCH_Instr_is_reg1_rd_a1),
                          .is_reg_rs2(FETCH_Instr_is_reg2_rd_a1), 
                          .valid_decode(FETCH_Instr_valid_decode_rd_a1), 
                          .dest_reg_valid(FETCH_Instr_dest_reg_valid_rd_a1), 
                          .reg_rs1(FETCH_Instr_reg_rs1_rd_a1),
                          .reg_rs2(FETCH_Instr_reg_rs2_rd_a1),
                          .valid_dest_reg_valid_rd(FETCH_Instr_valid_dest_reg_valid_rd_a1),
                          .goodPathMask(FETCH_Instr_goodPathMask_rd_a1),
                          .second_issue(FETCH_Instr_second_issue_rd_a1), 
                          .dest_reg(FETCH_Instr_dest_reg_rd_a1),
                          .dest_reg_now(FETCH_Instr_dest_reg_now_rd_a1), 
                          .rslt(FETCH_Instr_rslt_rd_a1),
                          .reg_wr_pending(FETCH_Instr_reg_wr_pending_rd_a1),
                          .replay_int(FETCH_Instr_replay_int_rd_a1),
                          .out_pending1(FETCH_Instr_out_pending1_rd_a1),
                          .out_pending2(FETCH_Instr_out_pending2_rd_a1),
                          .reg_value1(FETCH_Instr_out_reg_value1_rd_a1[31:0]),
                          .reg_value2(FETCH_Instr_out_reg_value2_rd_a1[31:0]), 
                          .dest_pending(FETCH_Instr_out_dest_pending_rd_a1),
                          .valid_dest_reg_valid_wr(FETCH_Instr_valid_dest_reg_valid_wr_a4),
                          .dest_reg_wr(FETCH_Instr_dest_reg_wr_a4),
                          .rslt_wr(FETCH_Instr_rslt_wr_a4),
                          .reg_wr_pending_wr(FETCH_Instr_reg_wr_pending_wr_a4)); 
                          
         //_@2
            /*SV_plus*/
               alu adder(
                         .clk(clk),
                         .reset(FETCH_Instr_reset_a2),
                         .reg_value1(FETCH_Instr_reg_value1_alu_a2), 
                         .reg_value2(FETCH_Instr_reg_value2_alu_a2),
                         .raw_i_imm(FETCH_Instr_raw_i_imm_alu_a2),
                         .raw_funct7_5(FETCH_Instr_raw_funct7_5_alu_a2), 
                         .valid_exe(FETCH_Instr_valid_exe_alu_a2), 
                         .addi_rslt(FETCH_Instr_addi_rslt_out_a2[31:0]),
                         .add_rslt(FETCH_Instr_add_rslt_out_a2[31:0]),
                         .sub_rslt(FETCH_Instr_sub_rslt_out_a2[31:0]));
                         
         //_@0
            /*SV_plus*/
               sram #(
                        .NB_COL(4),                           // Specify number of columns (number of bytes)
                        .COL_WIDTH(8),                        // Specify column width (byte width, typically 8 or 9)
                        .RAM_DEPTH(2048),                     // Specify RAM depth (number of entries)
                        .RAM_PERFORMANCE("LOW_LATENCY"), // Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
                        .INIT_FILE("./../mem.hex")                        // Specify name/location of RAM initialization file if using one (leave blank if not)
                      )memory(
                       .addra(FETCH_Instr_addr_instr_sram_a0),   // Port A address bus, width determined from RAM_DEPTH
                       .addrb(FETCH_Instr_addr_data_sram_a4),   // Port B address bus, width determined from RAM_DEPTH
                       .dina(0),   // Port A RAM input data
                       .dinb(FETCH_Instr_din_data_a4),   // Port B RAM input data
                       .clka(clk),                            // Clock
                       .wea(0),                // Port A write enable
                       .web(FETCH_Instr_web_a4),                // Port B write enable
                       .ena(1),                            // Port A RAM Enable, for additional power savings, disable port when not in use
                       .enb(1),                             // Port B RAM Enable, for additional power savings, disable port when not in use
                       .rsta(FETCH_Instr_reset_a0),                            // Port A output reset (does not affect memory contents)
                       .rstb(FETCH_Instr_reset_a0),                            // Port B output reset (does not affect memory contents)
                       .regcea(0),                          // Port A output register enable
                       .regceb(0),                          // Port B output register enable
                       .douta(FETCH_Instr_dout_instr_a0[31:0]), // Port A RAM output data
                       .doutb(FETCH_Instr_dout_data_a4[31:0])  // Port B RAM output data
                     );
endgenerate
         
   
//_\SV
   endmodule

